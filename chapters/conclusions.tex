\chapter{Conclusions}
\label{chp:conclusions}
We formally presented a dynamic memory management extension for the reversible object-oriented programing language, \textsc{Roopl}, in the form of the superset language \rooplpp. The extension expands upon the previously presented static typing system defining well-typedness. The language successfully extends the expressiveness of its predecessor by allowing more flexibility within the domain of reversible object-oriented programming. With \rooplpp we, as reversible programmers, can now define and model non-trivial dynamic data structures in a reversible setting, such as lists, trees and graphs. We illustrated this by example programs such as a new reversible Turing machine simulator along with implementations for linked lists, doubly-linked lists and binary trees as well as techniques for traversing these. Besides expanding the expressiveness of \textsc{Roopl}, we have also shown that complex dynamic data structures are not only feasible, but furthermore does not contradict the reversible computing paradigm.

We presented various dynamic memory management layouts and how each would translate into the reversible allocation algorithms. Weighing the advantages and disadvantages of each, the Buddy Memory layout was found to translate into reversible code very naturally with few side effects and addressed a number of disadvantages found in other considered layouts. With dynamically lifetimed objects the allocation and deallocation order is important in terms of a entirely garbage-free computation. In most cases with \rooplpp, we only obtain partially garbage-free computations, as our free lists might not be restored to their original form, without an effective garbage collector design for the memory manager.

Techniques for clean translations of extended parts of the language, such as the memory manager and the new static array type have been demonstrated and implemented in a proof-of-concept compiler for validation.

With the dynamic memory manager for reversible object-oriented programming languages, exemplified by \rooplpp, we have successfully taking an additional step in the direction towards high-level abstractions reversible computations.  

\section{Future Work}
\label{sec:future-work}
Naturally with the discovery of feasibility of non-trivial, reversible data structures with the introduction of \rooplpp, further study of design and implementation of reversible algorithms working with these data structures are an obvious contender for future research. Data structures such as lists, graphs and trees could potentially provide very interesting future reversible programs.

In terms of the future of reversible object-oriented languages, additional works could be made to extend the static array type with a fully dynamic array supporting multiple dimensionality. This addition could further help the discovery and research of reversible data structures such as trees and graphs. Such an extension could perhaps be added via a \textbf{put} and \textbf{take} statement pair, being each others inverse. After a dynamic array has been declared, it could automatically reallocate or upscale its internal space when putting new data outside of its current bounds. In reverse, the space could shrink or reallocate when removing the largest indexed value. The current memory management layout will still suffice for this extension.

Finally, more research could be conducted into reversible heap managers. We provided a simple manager which translated to our problem domain naturally. To obtain completely garbage free computations, a garbage collector could be designed to work with the reversible Buddy Memory memory manager. A reversible garbage collector has also been designed and shown feasible for the reversible functional language \textsc{Rcfun} in~\cite{tm:garbage}. This garbage collector could perhaps be converted to an object-oriented setting. Additionally, experimentation with implementing the Buddy Memory layout into other reversible languages with dynamic allocation and deallocation such as \textsc{R-While} and \textsc{R-Core} provides an interesting opportunity~\cite{rg:rwhile, rg:rcore}.
