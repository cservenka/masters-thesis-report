\chapter{The \textsc{Roolp\texttt{++}} Language}
With the design and implementation of the \textsc{Reversible Object-Oriented Programming Language} (\textsc{Roopl}), the first steps into the uncharted lands of Object-Oriented Programming (OOP) and reversibility was taken. In this chapter, we will present \rooplpp, the natural successor of \textsc{Roopl}, improving the language's object instantiation by letting objects live outside \texttt{construct / deconstruct} blocks, allowing complex, reversible programs to be written using OOP methodologies. As with its predecessor, \rooplpp is purely reversible and each component of a program written in \rooplpp is locally invertible. This ensures no computation history is required nor added program size for backwards direction program execution.\\

\texttt{TODO: Arrays at some point}\\

\texttt{TODO: \rooplpp example program}\\

\texttt{Idea: Let \rooplpp be a superset of \textsc{Roopl}}\\

\texttt{Idea: String type?}

\newpage
\section{Syntax}
A \rooplpp program consists, analogously to a \textsc{Roopl} program, of one or more class definitions, each with a varying number of fields and class methods.\\

\texttt{TODO: Local block}

\begin{figure}[h]
\centering
\vspace{3mm}

\textbf{\rooplpp Grammar}

\begin{align}
    prog		\quad&::= \quad cl^+ \tag{program}\\
    cl			\quad&::=\quad \textbf{class}\ c\ (\textbf{inherits}\ c)^?\ (t\ x)^*\ m^+\tag{class definition}\\
    t			\quad&::=\quad \textbf{int}\ |\ c\tag{data type}\\
    m			\quad&::=\quad \textbf{method}\ q\textbf{\texttt{(}}t\ x,\ \dots,\ t\ x\textbf{\texttt{)}}\ s\tag{method}\\
    s			\quad&::=\quad x\ \odot\textbf{\texttt{=}}\ e\ |\ x\ \textbf{\texttt{<=>}}\ x\tag{assignment}\\
    			&\ |\ \qquad \textbf{if}\ e\ \textbf{then}\ s\ \textbf{else}\ s\ \textbf{fi}\ e\tag{conditional}\\
    			&\ |\ \qquad \textbf{from}\ e\ \textbf{do}\ s\ \textbf{loop}\ s\ \textbf{until}\ e\tag{loop}\\
    			&\ |\ \qquad \textbf{new}\ c\ x  \tag{object construction}\\
    			&\ |\ \qquad \textbf{delete}\ c\ x \tag{object deconstruction}\\
    			&\ |\ \qquad \textbf{call}\ q\textbf{\texttt{(}}x,\ \dots,\ x\textbf{\texttt{)}}\ |\ \textbf{uncall}\ q\textbf{\texttt{(}}x,\ \dots,\ x\textbf{\texttt{)}}\tag{local method invocation}\\
    			&\ |\ \qquad \textbf{call}\ x\textbf{\texttt{::}}q\textbf{\texttt{(}}x,\ \dots,\ x\textbf{\texttt{)}}\ |\ \textbf{uncall}\ x\textbf{\texttt{::}}q\textbf{\texttt{(}}x,\ \dots,\ x\textbf{\texttt{)}}\tag{method invocation}\\
    			&\ |\ \qquad \textbf{skip}\ |\ s\ s\tag{statement sequence}\\
    e			\quad&::=\quad \overline{n}\ |\ x\ |\ \textbf{\texttt{nil}}\ |\ e\ \otimes\ e\tag{expression}\\
    \odot	\quad&::=\quad \textbf{\texttt{+}}\ |\ \textbf{\texttt{-}}\ |\ \textbf{\texttt{\^}}\tag{operator}\\
    \otimes\quad&::=\quad \odot\ |\ \textbf{\texttt{*}}\ |\ \textbf{\texttt{/}}\ |\ \textbf{\texttt{\%}}\ |\ \textbf{\texttt{\&}}\ |\ \textbf{\texttt{|}}\ |\ \textbf{\texttt{\&\&}}\ |\ \textbf{\texttt{||}}\ |\ \textbf{\texttt{<}}\ |\ \textbf{\texttt{\textgreater}}\ |\ \textbf{\texttt{=}}\ |\ \textbf{\texttt{!=}}\ |\ \textbf{\texttt{<=}}\ |\ \textbf{\texttt{\textgreater=}}\tag{operator}
\end{align}

\vspace{2mm}
\textbf{Syntax Domains}

\begin{align*}
    prog &\in \text{Programs} & s &\in \text{Statements}      & n &\in \text{Constants} \\
    cl   &\in \text{Classes}  & e &\in \text{Expressions}     & x &\in \text{VarIDs}    \\
    t    &\in \text{Types}    & \odot &\in \text{ModOps}      & q &\in \text{MethodIDs} \\
    m    &\in \text{Methods}  & \otimes &\in \text{Operators} & c &\in \text{ClassIDs}
\end{align*}

\caption{Syntax domains and EBNF grammar for \rooplpp}
\label{fig:roopl-grammar}
\end{figure}



\newpage
\section{Object Instantiation}
\texttt{TODO}

\section{Vector Instantiation}
\texttt{Idea: Implement dynamic array (named vector).}\\
\texttt{Idea: Instantiate with alloc call.}\\
\texttt{Idea: Inverse operation: dealloc}\\

