\chapter{The \textsc{Roolp\texttt{++}} Language}
\label{chp:rooplpp}
With the design and implementation of the \textsc{Reversible Object-Oriented Programming Language} (\textsc{Roopl}), the first steps into the uncharted lands of Object-Oriented Programming (OOP) and reversibility was taken. In this chapter, we will present \rooplpp, the natural successor of \textsc{Roopl}, improving the language's object instantiation by letting objects live outside \texttt{construct / deconstruct} blocks, allowing complex, reversible programs to be written using OOP methodologies. As with its predecessor, \rooplpp is purely reversible and each component of a program written in \rooplpp is locally invertible. This ensures no computation history is required nor added program size for backwards direction program execution.

Inspired by other language successors such as \textsc{C\texttt{++}} was to \textsc{C}, \rooplpp is a superset of \textsc{Roopl}, containing all original functionality of its predecessor, extended with new object instantiation methods for increased programming usability and an array type.

%TODO: Insert example of ROOPL++ program here!
\begin{figure}
    \texttt{TODO}
    \caption{Example \rooplpp program}   
\end{figure}
\newpage

% TODO: Update new / delete for array assignment
\section{Syntax}
\label{sec:syntax}
A \rooplpp program consists, analogously to a \textsc{Roopl} program, of one or more class definitions, each with a varying number of fields and class methods. The program's entry point is a nullary main method, defined exactly once and is instantiated during program start-up. Fields of the main object will serve as output of the program, exactly as in \textsc{Roopl}.
\begin{figure}[h]
    \centering
    \vspace{3mm}
    \textbf{\rooplpp Grammar}
    \begin{align}
    prog		\quad&::= \quad cl^+ \tag{program}\\
    cl			\quad&::=\quad \textbf{class}\ c\ (\textbf{inherits}\ c)^?\ (t\ x)^*\ m^+\tag{class definition}\\
    d           \quad&::=\quad c\ |\ \textbf{vector}\texttt{<}t\texttt{>} \tag{class and array}\\
    t			\quad&::=\quad \textbf{int}\ |\ c\ |\ \textbf{vector}\texttt{<}t\texttt{>} \tag{data type}\\
    m			\quad&::=\quad \textbf{method}\ q\textbf{\texttt{(}}t\ x,\ \dots,\ t\ x\textbf{\texttt{)}}\ s\tag{method}\\
    s			\quad&::=\quad x\ \odot\textbf{\texttt{=}}\ e\ |\ x\ \textbf{\texttt{<=>}}\ x\tag{assignment}\ |\ x[e]\ \odot\textbf{\texttt{=}}\ e\\\
    			&\ |\ \qquad \textbf{if}\ e\ \textbf{then}\ s\ \textbf{else}\ s\ \textbf{fi}\ e\tag{conditional}\\
    			&\ |\ \qquad \textbf{from}\ e\ \textbf{do}\ s\ \textbf{loop}\ s\ \textbf{until}\ e\tag{loop}\\
                &\ |\ \qquad \textbf{construct}\ d\ x\quad s\quad\textbf{destruct}\ x\tag{object block}\\
                &\ |\ \qquad \textbf{local}\ t\ x\ \texttt{=}\ e\quad s\quad\textbf{delocal}\ t\ x\ \texttt{=}\ e\tag{local variable block}\\
                &\ |\ \qquad \textbf{new}\ d\ x\ |\ \textbf{delete}\ d\ x \tag{object con- and destruction}\\
                &\ |\ \qquad \textbf{copy}\ d\ x\ x\ |\ \textbf{uncopy}\ d\ x\ x \tag{reference con- and destruction}\\
    			&\ |\ \qquad \textbf{call}\ q\textbf{\texttt{(}}x,\ \dots,\ x\textbf{\texttt{)}}\ |\ \textbf{uncall}\ q\textbf{\texttt{(}}x,\ \dots,\ x\textbf{\texttt{)}}\tag{local method invocation}\\
    			&\ |\ \qquad \textbf{call}\ x\textbf{\texttt{::}}q\textbf{\texttt{(}}x,\ \dots,\ x\textbf{\texttt{)}}\ |\ \textbf{uncall}\ x\textbf{\texttt{::}}q\textbf{\texttt{(}}x,\ \dots,\ x\textbf{\texttt{)}}\tag{method invocation}\\
    			&\ |\ \qquad \textbf{skip}\ |\ s\ s\tag{statement sequence}\\
    e			\quad&::=\quad \overline{n}\ |\ x\ |\ x[e]\ |\ \textbf{\texttt{nil}}\ |\ e\ \otimes\ e\tag{expression}\\
    \odot	\quad&::=\quad \textbf{\texttt{+}}\ |\ \textbf{\texttt{-}}\ |\ \textbf{\texttt{\^}}\tag{operator}\\
    \otimes\quad&::=\quad \odot\ |\ \textbf{\texttt{*}}\ |\ \textbf{\texttt{/}}\ |\ \textbf{\texttt{\%}}\ |\ \textbf{\texttt{\&}}\ |\ \textbf{\texttt{|}}\ |\ \textbf{\texttt{\&\&}}\ |\ \textbf{\texttt{||}}\ |\ \textbf{\texttt{<}}\ |\ \textbf{\texttt{\textgreater}}\ |\ \textbf{\texttt{=}}\ |\ \textbf{\texttt{!=}}\ |\ \textbf{\texttt{<=}}\ |\ \textbf{\texttt{\textgreater=}}\tag{operator}
    \end{align}
    \vspace{2mm}
    \textbf{Syntax Domains}
    \begin{align*}
    prog &\in \text{Programs} & s &\in \text{Statements}      & n &\in \text{Constants} \\
    cl   &\in \text{Classes}  & e &\in \text{Expressions}     & x &\in \text{VarIDs}    \\
    t    &\in \text{Types}    & \odot &\in \text{ModOps}      & q &\in \text{MethodIDs} \\
    m    &\in \text{Methods}  & \otimes &\in \text{Operators} & c &\in \text{ClassIDs}
    \end{align*}
    \caption{Syntax domains and EBNF grammar for \rooplpp}
    \label{fig:roopl-grammar}
\end{figure}

% TODO: Add short line about vectors
The \rooplpp grammar extends \textsc{Roopl}'s grammar with a new dynamic array type in form of \textbf{vector}s and a new object lifetime option in form of working with objects outside of blocks, using the \textbf{new} and \textbf{delete} approach. Furthermore, the local block extension proposed in~\cite{th:roopl} has become a standard part of the language. Class definitions remains unchanged, an consists of a \textbf{class} keyword followed by a class name. Subclasses must be specified using the \textbf{inherits} keyword and a following parent class name. Classes can have any number of fields of any of the data types, including the new vector type. A class definition is required to include at least one method, defined by the \textbf{method} keyword followed by a a method name, a comma-separated list of parameters and a body.

Reversible assignments for integer variables and vector elements uses similar syntax as \textsc{Janus} assignments, by updating a variable through any of the addition (\texttt{+=}), subtraction or bitwise XOR operators. As with \textsc{Janus}, when updating a variable $x$ using any of said operators, the right-hand side of the operator argument must be entirely independent of $x$ to maintain reversibility. Usage of these reversible assignment operators for object or vector variables are undefined.

\rooplpp objects can be instantiated in two ways. Either using object blocks known from \textsc{Roopl}, or by using the \textbf{new} statement. The object-blocks have a limited lifetime, as the object only exists within the \textbf{construct} and \textbf{destruct} segments. Using \textbf{new} allows the object to live until program termination, if the program terminates with a \textbf{delete} call. By design, it is the programmers responsibility to deallocate objects instantiated by the usage of \textbf{new}.

The methodologies for argument aliasing and its restrictions on method on invocations from \textsc{Roopl} carries over in \rooplpp and object fields are as such disallowed as arguments to local methods to prevent irreversible updates and non-local method calls to a passed objects are prohibited. The parameter passing scheme remains call-by-reference and the \textsc{Roopl}'s object model remains unchanged in \rooplpp.

%TODO: Something about referencing?
\section{Object Instantiation}
\label{sec:object-instantiation}
%TODO: Example of new/delete
Object instantiation through the \textbf{new} statement, follows the pattern of the mechanics of the \textbf{construct}/\textbf{destruct} blocks from \textsc{Roopl}, except for the less limited scoping and lifetime of objects. The mechanisms of the statement 

\begin{align*}
\textbf{construct}\ c\ x\ \quad s\ \quad \textbf{destruct}\ x
\end{align*}

are as follows:

\begin{enumerate}
\item Memory for an object of class $c$ is allocated. All fields are automatically zero-initialized by virtue of residing in already zero-cleared memory.
\item The block statement $s$ is executed, with the name $x$ representing a reference to the newly allocated object.
\item The reference $x$ may be modified by swapping its value with that of other references of the same type, but it should be restored to its original value within the statement block $s$, otherwise the meaning of the object block is undefined.
\item Any state that is accumulated within the object should be cleared or uncomputed before the end of the statement is reached, otherwise the meaning of the object block is undefined.
\item The zero-cleared memory is reclaimed by the system.
\end{enumerate}

The statement pair consisting of

\begin{align*}
\textbf{new}\ c\ x\ \quad s\ \quad \textbf{delete}\ c\ x\
\end{align*}

could be considered an \textit{fluid} block, meaning we can have overlapping blocks. We can as such initialize an object $x$ of class $c$ and an object $y$ of class $d$ and destroy $x$ before we destroy $y$, a feature that was not possible in \textsc{Roopl}. The mechanisms of the \textbf{new} statement are as follows

\begin{enumerate}
    \item Memory for an object of class $c$ is allocated. All fields are automatically zero-initialized by virtue of residing in already zero-cleared memory.
    \item The block statement $s$ is executed, with the name $x$ representing a reference to the newly allocated object.
\end{enumerate}

and the mechanisms of the \textbf{delete} statement are as follow

\begin{enumerate}
    \item The reference $x$ may be modified by swapping its value with that of other references of the same type, but it should be restored to its original value before a \textbf{delete} statement is called on $x$, otherwise the meaning of the object deletion is undefined.
    \item Any state that is accumulated within the object should be cleared or uncomputed before the \textbf{delete} statement is executed, otherwise the meaning of the object block is undefined.
    \item The zero-cleared memory is reclaimed by the system.
\end{enumerate}

The mechanisms of the \textbf{new} and \textbf{delete} statements are, essentially, a split of the mechanisms of the \textbf{construct}/\textbf{destruct} blocks into two separate statements. As with \textsc{Roopl}, fields must be zero-cleared after object deletion, otherwise it is impossible for the system to reclaim the memory reversibly. This is the responsibility of the of the programmer to maintain this, and to ensure that objects are indeed deleted in the first place. A \textbf{new} statement without a corresponding \textbf{delete} statement targeting the same object further ahead in the program is undefined.

\section{Object Referencing}
Besides dynamically scoped objects, \rooplpp also increases program flexibility by allowing multiple references to objects through the usage of the \textbf{copy} statement. Once instantiated through either a \textbf{new} or \textbf{construct/destruct} block, an object reference can be copied into a new variable. The reference acts as a regular class instance and can be modified through methods as per usual. To delete a reference, the logical inverse statement \textbf{uncopy} must be used.

The syntax for referencing consists of the statement
\begin{align*}
    \textbf{copy}\ c\ x\ x'
\end{align*}
which makes a reference of variable $x$, an instance of class $c$, and stores the reference in variable $x'$.

For deleting copies, the following statement is used
\begin{align*}
    \textbf{uncopy}\ c\ x\ x'
\end{align*}    
which simply zero-clears variable $x'$, which is a reference to variable $x$, an instance of class $x$.

The mechanism of the \textbf{copy} statement is simply as follows
\begin{enumerate}
    \item The memory address stored in variable $x$ is copied into the zero-cleared variable $x'$. If $x'$ is not zero-cleared or $x$ is not a class instance, then \textbf{copy} is undefined.
\end{enumerate}

The mechanism of the \textbf{uncopy} statement is simply as follows
\begin{enumerate}
    \item The memory address stored in variable $x'$ is zero-cleared if it matches the address stored in $x$. If $x'$ is not a copy of $x$ or $x$ has been zero-cleared before the \textbf{uncopy} statement is executed, said statement is undefined.
\end{enumerate}
As references does not require all fields to be zero-cleared (as they simply are pointers to existing objects), the reversible programmer should carefully ensure that all references to objects are un-copied before deleting said object, as copied references to cleared objects would be pointing to cleared memory, which might be used later by the system. These type of references are also known as \textit{dangling pointers}.

It should be noted, that from a language design perspective, it is the programmer's responsibility to ensure such situations does not occur. From an implementation perspective, such situations are usually checked by the compiler either statically during compilation or during the actual runtime of the program. This is addressed later in section .... % TODO: Reference to error handling and referencing counting sections


\section{Vector Model}
\label{sec:vector-model}
Besides asymmetric object lifetimes, \rooplpp also introduces reversible, dynamic arrays in form of the \textbf{vector} type. While \textsc{Roopl} on featured integers and custom data types in form of classes, one of its main inspirations, \textsc{Janus}, implemented static, reversible arrays~\cite{ty:janus}.

While \textsc{Roopl} by design did not include any data storage language constructs, as they are not especially noteworthy nor interesting from an OOP perspective, they do generally improve the expressiveness of the language. For \rooplpp these were decided to be part of the core language as array, especially multi-dimensional, dynamic arrays become interesting from a memory management perspective.

\rooplpp's dynamic arrays expand upon the array model from \textsc{Janus}. Arrays are index by integers, starting from 0. In \textsc{Janus}, only integer arrays were allowed and arrays were one-dimensional. In \rooplpp arrays of any type can be defined, meaning either integer arrays, custom data types in form of class array or from other array types and have as such potential to be multi-dimensional. 

Array element accessing is permitted using the bracket notation expression presented in \textsc{Janus}. Accessing an out-of-bounds index is undefined.
Vector instantiation and element assignments, aliasing and circularity is described in detail in the following section.

Vectors can contain elements of different classes if, say class $A$ and $B$ both inherit from some class $C$ and vector $x$ is a $\textbf{vector}\texttt{<}C\texttt{>}$ type. In this case, the array can hold elements of type $A$, $B$, and $C$.

\section{Vector Instantiation}
\label{sec:vector-instatiation}
Vector instantiation uses the \textbf{new} and \textbf{delete} keywords to reversibly construct and destruct vector types. In irreversible OOP languages,  instantiation and insertion/deletion of elements are usually executed in the the following steps for empty, dynamic arrays

\begin{enumerate}
    \item A small amount of memory is reserved for the overhead of an array
    \item Once the array is non-empty, a pointer for the overhead place in memory points to the beginning of the data.
    \item As elements are inserted, the data memory is expanded to fit new elements, if we need indexes higher than the current size of the array.
    \item As the highest indexed elements are deleted, the data memory is collapsed to reduce the overall size of the array object.
\end{enumerate}

Consider the statement
\begin{align*}
\textbf{new}\ \textbf{vector}\texttt{<}\textbf{int}\texttt{>}\ x
\end{align*} 

in which we reserve memory for an \textbf{int} \textbf{vector} with the mechanics following mechanics

\begin{enumerate}
    \item A small amount of memory is reserved for the overhead of an array.
    \item On the first element insert, e.g. $x[n]\ \texttt{+=}\ 1$, a block of memory suitable for storing $|[0, 1, ..., n]|$ integer values are reserved, with the newly updated value of $x[n]$ inserted and uninitialized cells zero-cleared, and a pointer from the overhead to the data is linked.
    \item If a value is inserted at, say, $x[n+1]$, a similar action is dispatched, but deallocating the old block after allocating the new one first.
    \item When the highest indexed cell element is zero-cleared, a allocation action is dispatched for obtaining a smaller block for our array data, while the old, larger block is freed.
\end{enumerate}

In \rooplpp, we only allow instantiation of empty, dynamic arrays. As shown above, Integer elements are assigned using one of the reversible assignment operators. For class \textbf{vector}s and \textbf{vector} \textbf{vectors}, we assign cell elements a little differently. We make use of the \textbf{new} and \textbf{delete} statements, but instead of specifying which variable should hold the newly created/deleted object or array, we specify which array cell it should be stored in. The mechanisms of these assignments are equal to the example for \textbf{int} \textbf{vector}s; we grow the array on assignments to higher-than-current-max indexes and we shrink on zero-clearing of highest-indexed element.

\texttt{TODO: Code example of assigning $\textbf{new}\ c\ x[3]$ to empty array}

As with \rooplpp objects instantiated outside of \textbf{construct}/\textbf{destruct} blocks, \textbf{vector}s must be deleted before program termination to reversibly allow the system to reclaim the memory. Before deletion of a vector, all its elements must be zero-cleared such that the array is shrunk to the empty array.

Consider the statement
\begin{align*}
\textbf{delete}\ \textbf{vector}\texttt{<}\textbf{int}\texttt{>}\ x
\end{align*}

with the following mechanics

\begin{enumerate}
\item The reference $x$ may be modified by swapping, assigning cell element values and zero-clearing cell element values, but must be restored to a 0-element sized array before the \textbf{delete} statement. Otherwise, the meaning of the statement is undefined.
\item If the reference $x$ is the empty array upon the \textbf{delete} statement execution, the zero-cleared memory is reclaimed by the system.
\end{enumerate}

With reversible, dynamic arrays of varying types and dimensionality, we must be extremely careful when updating and assigning values, to ensure we maintain reversibility and avoid irreversible statements. Therefore, when assigning or updating integer elements with one of the reversible assignment operators, we prohibit the cell value from being reference on the right hand side, meaning the following statement is prohibited
\begin{align*}
x[5] \texttt{+=}\ x[5] + 1 
\end{align*}

However, we do allow other, initialized (non-zero-cleared array elements) to be referenced in the right hand side of the statement.

\section{Local blocks}
\label{sec:local-blocks}
%TODO: Alias for construct/destruct block for objects


\section{Type System}
\label{sec:type-system}
% TODO: Cite winskell
The type system of \rooplpp expands on the type system of \textsc{Roopl} presented by~\citeauthor{th:roopl} in~\cite{th:roopl} and is analogously described by syntax-directed inference typing rules in the style of Winskell. As \rooplpp introduces two new types in form of \textit{references} and \textit{vectors}, a few \textsc{Roopl} typing rules must be modified to accommodate these added types. For completeness all typing rules, including unmodified rules, are included in the following sections.

\subsection{Preliminaries}
\label{subsec:preliminaries}
The types in \rooplpp are given by the following grammar:
\begin{equation*}
    \tau ::= \textbf{int}\ |\ c \in \text{ClassIDs}\ |\ r \in \text{ReferenceIDs}\ |\ v \in \text{VectorIDs}
\end{equation*}
The type environment $\Pi$ is a finite map paring variables to types, which can be applied to an identifier $x$ using the $\Pi(x)$ notation. Notation $\Pi' = \Pi[x \mapsto \tau]$ defines updates and creation of a new type environment $\Pi'$ such that $\Pi'(x) = \tau$ and $\Pi'(y) = \Pi(y)$ if $x \not= y$, for some variable identifier $x$ and $y$. The empty type environment is denoted as $[\ ]$ and the function $vars\ :\ Expressions\ \to \text{VarIDs}$ is described by the following definition
\begin{align*}
    &\text{vars}(\bar{n}) &&= \emptyset\\
    &\text{vars}(\textbf{nil}) &&= \emptyset\\
    &\text{vars}(x) &&= \{\ x\ \}\\
    &\text{vars}(e_1 \otimes e_2) &&= \text{vars}(e_1) \cup \text{vars}(e_2).
\end{align*}
The binary subtype relation $c_1 \prec: c_2$ is required for supporting subtype polymorphism as is defined as follows
\begin{align*}
    c_1 &\prec: c_2 &&\text{if}\ c_1\ \text{inherits from}\ c_2\\
    c   &\prec: c   &&(reflexivity)\\
    c_1 &\prec: c_3 &&\text{if}\ c_1 \prec: c_2\ \text{and}\ c_2 \prec: c_3\ (transitivity)
\end{align*}

Furthermore, we formally define object models, in such a way that inherited fields and methods are included, unless overridden by the derived fields. Therefore, we define $\Gamma$ to be the class map of a program $p$, such that $\Gamma$ is a finite map from class identifiers to tuples of methods and fields for the class $p$. Application of a class map $\Gamma$ to some class $cl$ is denoted as $\Gamma(cl)$. Construction of a class map is done through function $gen$, as shown in figure~\ref{fig:class-gen}. Figure~\ref{fig:fields-methods} defines the $fields$ and $methods$ functions to determine these given a class. Set operation $\uplus$ defines method overloading by dropping base class methods if a similarly named method exists in the derived class. The definitions shown in Figure~\ref{fig:class-gen} and~\ref{fig:fields-methods} are graciously borrowed from~\cite{th:roopl}.
 
\begin{figure}[ht]
    \centering
    $\text{gen}\Big(\overbrace{cl_1,\ ...,\ cl_n}^p\Big) = \overbrace{\Big[ \alpha(cl_1) \mapsto \beta(cl_1),\ ...,\ \alpha(cl_n) \mapsto \beta(cl_n) \Big]}^\Gamma$\\

    \vskip 2em
    
    $\alpha\Big(\textbf{class}\ c\ \cdots\Big) = c$
    \hskip 2em
    $\beta(cl) = \Big(\text{fields}(cl),\ \text{methods}(cl) \Big)$

    \caption{Definition $gen$ for constructing the finite class map $\Gamma$ of a given program $p$. From~\cite{th:roopl}}
    \label{fig:class-gen}
\end{figure}

\begin{figure}[H]
    \centering
    \begin{equation*}
        \text{fields}(cl) = \begin{cases}
            \eta(cl)  & \text{if}\ cl \sim [ \textbf{class}\ c\ \cdots ]\\
            \eta(cl) \cup \text{fields}\Big(\alpha^{-1}(c')\Big) & \text{if}\ cl \sim [ \textbf{class}\ c\ \textbf{inherits}\ c'\ \cdots ]
        \end{cases}
    \end{equation*}

    \vskip 1em

    \begin{equation*}
        \text{methods}(cl) = \begin{cases}
            \delta(cl) & \text{if}\ cl \sim [ \textbf{class}\ c\ \cdots ]\\
            \delta(cl) \uplus \text{methods}\Big(\alpha^{-1}(c')\Big) & \text{if}\ cl \sim [\textbf{class}\ c\ \textbf{inherits}\ c'\ \cdots]
        \end{cases}
    \end{equation*}

    \vskip 1em

    \begin{equation*}
        A\ \uplus B\ \overset{def}{=}\ A \cup \bigg\{ m \in B\ \bigg\vert\ \nexists\  m' \Big( \zeta(m') = \zeta(m) \wedge m' \in A \Big) \bigg\}
    \end{equation*}

    $\zeta\Big( \textbf{method}\ q\ (\cdots)\ s \Big) = q$
    \hskip 2em
    $\eta\Big( \textbf{class}\ c\ \cdots\ \overbrace{t_1 f_1\ \cdots\ t_n f_n}^{fs}\ \cdots \Big) = fs$

    \begin{equation*}
        \delta\Big( \textbf{class}\ c\ \cdots \overbrace{\textbf{method}\ q_1\ (\cdots)\ s_1\ \cdots\ \textbf{method}\ q_n\ (\cdots)\ s_n }^{ms}\ \cdots \Big) = ms
    \end{equation*}
    \caption{Definition of fields and methods from~\cite{th:roopl}}
    \label{fig:fields-methods}
\end{figure}

\subsection{Expressions}
\label{subsec:expressions}
The type judgment

\begin{prooftree}
	\AXC{}
    \UIC{$\Pi \vdash_{expr}\ e : \tau$} 
\end{prooftree} 

defines the type of expressions. The judgment reads as: under type environment $\Pi$, expression $e$ has type $\tau$.

\begin{figure}[ht]
    \begin{center}
        \AXC{} % Con
        \RL{\textsc{T-Con}}
        \UIC{$\Pi \vdash_{expr}\ n : \textbf{int}$} 
        \DP
        \hskip 2em % Var
        \AXC{$\Pi(x) = \tau$}
        \RL{\textsc{T-Var}}
        \UIC{$\Pi \vdash_{expr}\ x : \tau$} 
        \DP
        \hskip 2em % Nil
        \AXC{$\tau \not= \textbf{int}$}
        \RL{\textsc{T-Nil}}
        \UIC{$\Pi \vdash_{expr}\ \textbf{nil}\ : \tau$}
        \DP
        
        \vskip 2em % BinOpInt
        \AXC{$\Pi \vdash_{expr}\ e_1 : \textbf{int}$}
        \AXC{$\Pi \vdash_{expr}\ e_2 : \textbf{int}$}
        \RL{\textsc{T-BinOpInt}}
        \BIC{$\Pi \vdash_{expr}\ e_1 \otimes e_2 : \textbf{int}$}
        \DP

        \vskip 2em % BinOpObj
        \AXC{$\Pi \vdash_{expr}\ e_1 : \textbf{int}$}
        \AXC{$\Pi \vdash_{expr}\ e_2 : \textbf{int}$}
        \AXC{$\ominus \in \{ \texttt{\textbf{=}}, \texttt{\textbf{!=}} \}$}
        \RL{\textsc{T-BinOpObj}}
        \TIC{$\Pi \vdash_{expr}\ e_1 \otimes e_2 : \textbf{int}$}
        \DP
    \end{center}
    \caption{Typing rules for expressions}
    \label{fig:typing-rules-expressions}
\end{figure}

The type rules \textsc{T-Con}, \textsc{T-Var} and \textsc{T-Nil} defines typing of the simplest expressions. Numeric literals are of type \textbf{int}, typing of variable expressions depends on the type of the variable in the type environment and the \textbf{nil} literal is a non-integer type. All Binary operations are defined for integers, while only equality-operators are defined for objects.

\subsection{Statements}
\label{subsec:statements}
The type judgment

\begin{prooftree}
	\AXC{}
    \UIC{$\langle \Pi,\ c\rangle\ \vdash_{stmt}^\Gamma\ s$} 
\end{prooftree} 

defines well-typed statements. The judgment reads as under type environment $\Pi$ within class $c$, statement $s$ is well-typed with class map $\Gamma$.
% TODO: Local block
\begin{figure}[H]
    \begin{center}
        % Assignment
        \AXC{$x \not\in \text{vars}(e)$}
        \AXC{$\Pi \vdash_{expr}\ e : \textbf{int}$}
        \AXC{$\Pi(x) = \textbf{int}$}
        \RL{\textsc{T-AssVar}}
        \TIC{$\langle \Pi, c \rangle \vdash^{\Gamma}_{stmt}\ x \odot= e$}
        \DP

        \vskip 2em
        
        % If
        \AXC{$\Pi \vdash_{expr}\ e_1 : \textbf{int}$}
        \AXC{$\langle \Pi, c \rangle \vdash^{\Gamma}_{stmt}\ s_1$}
        \AXC{$\langle \Pi, c \rangle \vdash^{\Gamma}_{stmt}\ s_2$}
        \AXC{$\Pi \vdash_{expr}\ e_2 : \textbf{int}$}
        \RL{\textsc{T-If}}
        \QIC{$\langle \Pi, c \rangle \vdash^{\Gamma}_{stmt}\ \textbf{if}\ e_1\ \textbf{then}\ s_1\ \textbf{else}\ s_2\ \textbf{fi}\ e_2$}
        \DP

        \vskip 2em

        % Loop
        \AXC{$\Pi \vdash_{expr}\ e_1 : \textbf{int}$}
        \AXC{$\langle \Pi, c \rangle \vdash^{\Gamma}_{stmt}\ s_1$}
        \AXC{$\langle \Pi, c \rangle \vdash^{\Gamma}_{stmt}\ s_2$}
        \AXC{$\Pi \vdash_{expr}\ e_2 : \textbf{int}$}
        \RL{\textsc{T-Loop}}
        \QIC{$\langle \Pi, c \rangle \vdash^{\Gamma}_{stmt}\ \textbf{from}\ e_1\ \textbf{do}\ s_1\ \textbf{loop}\ s_2\ \textbf{until}\ e_2$}
        \DP

        \vskip 2em
        
        % ObjectBlock + Skip
        \AXC{$\langle \Pi[x \mapsto c'], c \rangle \vdash^{\Gamma}_{stmt}\ s$}
        \RL{\textsc{T-ObjBlock}}
        \UIC{$\langle \Pi, c \rangle \vdash^{\Gamma}_{stmt}\ \textbf{construct}\ c'\ x\quad s\quad \textbf{destruct}\ x$} 
        \DP
        \hskip 2em
        \AXC{}
        \RL{\textsc{T-Skip}}
        \UIC{$\langle \Pi, c \rangle \vdash^{\Gamma}_{stmt}\ \textbf{skip}$} 
        \DP

        \vskip 2em

        % Object new
        \AXC{}
        \RL{\textsc{T-ObjNew}}
        \UIC{$\langle \Pi[x \mapsto c'], c \rangle  \vdash^{\Gamma}_{stmt}\ \textbf{new}\ c'\ x$} 
        \DP
        \hskip 2em
        \AXC{$\Pi(x) = c'$}
        \RL{\textsc{T-ObjDlt}}
        \UIC{$\langle \Pi \setminus \{x\}, c \rangle  \vdash^{\Gamma}_{stmt}\ \textbf{delete}\ c'\ x$} 
        \DP

        \vskip 2em

        % Object delete
        \AXC{$\Pi(x) = c'$}
        \RL{\textsc{T-Cp}}
        \UIC{$\langle \Pi[x' \mapsto c'], c \rangle  \vdash^{\Gamma}_{stmt}\ \textbf{copy}\ c'\ x\ x'$} 
        \DP
        \hskip 2em
        \AXC{$\Pi(x) = c'$}
        \AXC{$\Pi(x') = c'$}
        \RL{\textsc{T-Ucp}}
        \BIC{$\langle \Pi \setminus \{x'\}, c \rangle  \vdash^{\Gamma}_{stmt}\ \textbf{uncopy}\ c'\ x\ x'$} 
        \DP

        \vskip 2em

        % Seq + SwapVar
        \AXC{$\langle \Pi, c \rangle \vdash^{\Gamma}_{stmt}\ s_1$}
        \AXC{$\langle \Pi, c \rangle \vdash^{\Gamma}_{stmt}\ s_2$}
        \RL{\textsc{T-Seq}}
        \BIC{$\langle \Pi, c \rangle \vdash^{\Gamma}_{stmt}\ s_1\ s_2$}
        \DP
        \hskip 2em
        \AXC{$\Pi(x_1) = \Pi(x_2)$}
        \RL{\textsc{T-SwpVar}}
        \UIC{$\langle \Pi, c \rangle \vdash^{\Gamma}_{stmt}\ x_1\ \texttt{\textbf{<=>}}\ x_2$}
        \DP

        \vskip 2em

        % T-Call
        \AXC{$\Gamma(\Pi(c)) = \Big( fields,\ methods \Big)$}
        \DP
        \AXC{$\Big( \textbf{method}\ q(t_1\ y_1,\ ...,\ t_n\ y_n)\ s \Big) \in methods$}
        \DP
        \AXC{$\{ x_1,\ ...,\ x_n \} \cap fields = \emptyset$}
        \AXC{$i \not= j \implies x_i \not= x_j$}
        \AXC{$\Pi(x_1) \prec: t_1\ \cdots\ \Pi(x_n) \prec: t_n$}
        \RL{\textsc{T-Call}}
        \TIC{$\langle \Pi, c \rangle \vdash^{\Gamma}_{stmt}\ \textbf{call}\ q(x_1,\ ...,\ x_n)$}
        \DP

        \vskip 2em
        
        % T-CallO
        \AXC{$\Gamma(\Pi(x_0)) = \Big( fields,\ methods \Big)$}
        \DP
        \AXC{$\Big( \textbf{method}\ q(t_1\ y_1,\ ...,\ t_n\ y_n)\ s \Big) \in methods$}
        \DP
        \AXC{$i \not= j \implies x_i \not= x_j$}
        \AXC{$\Pi(x_1) \prec: t_1\ \cdots\ \Pi(x_n) \prec: t_n$}
        \RL{\textsc{T-CallO}}
        \BIC{$\langle \Pi, c \rangle \vdash^{\Gamma}_{stmt}\ \textbf{call}\ x_0::q(x_1,\ ...,\ x_n)$}
        \DP

        \vskip 2em

        % UC and UCO
        \AXC{$\langle \Pi, c \rangle \vdash^{\Gamma}_{stmt}\ \textbf{call}\ q(x_1,\ ...,\ x_n)$}
        \RL{\textsc{T-Uc}}
        \UIC{$\langle \Pi, c \rangle \vdash^{\Gamma}_{stmt}\ \textbf{uncall}\ q(x_1,\ ...,\ x_n)$}
        \DP
        \hskip 2em
        \AXC{$\langle \Pi, c \rangle \vdash^{\Gamma}_{stmt}\ \textbf{call}\ x_0::q(x_1,\ ...,\ x_n)$}
        \RL{\textsc{T-Uco}}
        \UIC{$\langle \Pi, c \rangle \vdash^{\Gamma}_{stmt}\ \textbf{uncall}\ x_0::q(x_1,\ ...,\ x_n)$}
        \DP
    \end{center}
    \caption{Typing rules for statements}
    \label{fig:typing-rules-statements}
\end{figure}

Typing rule \textsc{T-AssVar} defines variable assignments for an integer variable and an integer expression result, given that the variable $x$ does not occur in the expression $e$. 

The type rules \textsc{T-If} and \textsc{T-Loop} defines reversible conditionals and loops as known from \textsc{Janus}, where entry and exit conditions are integers and branch and loop statements are well-typed statements. 

The object block, introduced in \textsc{Roopl}, is only well-typed if its body statement is well-typed. 

The \textsc{T-ObjNew} and \textsc{T-ObjDlt} rules defines well-typed \textbf{new} and \textbf{text}{delete} statements for dynamically scoped objects. The \textbf{new} statement is always well-typed, as long as $c' \in \text{classIDs}$ and the \textbf{delete} is well-typed if the type of $x$ under type environment $\Pi$ is equal to $c'$. 

Typing rules \textsc{T-Cp} and \textsc{T-Ucp} defines well-type reference copy and un-copying statements. A well-typed \textbf{copy} statement requires that the type of $x$ is $c'$ under type environment $\Pi$, while a well-typed \textbf{uncopy} statement further requires that the type of $x'$ is $c'$ too. For \textbf{new} and \textbf{copy} statements, the type environment is updated with a new type for $x$ and $x'$ respectively. For \textbf{delete} and \textbf{uncopy} statements, $x$ and $x'$ is removed from the type environment.

The \textbf{skip} statement is always well-typed, while a sequence of statements are well-typed if each of the provided statements are. Variable \textbf{swap} statements are well-typed if both operands are of the same type under type environment $\Pi$.

As with \textsc{Roopl}, well-typing of local method invocation is defined in rule \textsc{T-Call} iff:
\begin{itemize}
    \item The number of arguments matches the method arity
    \item No class fields are present in the arguments passed to the method (To prevent irreversible updates)
    \item The argument list contains unique elements
    \item Each argument is a subtype of the type of the equivalent formal parameter. 
\end{itemize}

For foreign method invocations, typing rule \textsc{T-CallO}. A foreign method invocation is well-typed using the same rules as for \textsc{T-Call} besides having no restrictions on class fields parameters in the arguments, but an added rule stating that the callee object $x_0$ must not be passed as an argument.

The typing rules \textsc{T-UC} and \textsc{T-UCO} defines uncalling of methods in terms of their respective inverse counterparts.

\subsection{Programs}
\label{subsec:programs} 
As with \textsc{Roopl}, a \rooplpp program is well-typed if all of its classes and their respective methods are well-typed and if there exists a nullary main methods. Figure~\ref{fig:typing-programs} shows the typing rules for class methods, classes and programs.

\begin{figure}[H]
    \begin{center}
        % Method
        \AXC{$\langle \Pi[x_1 \mapsto t_1,\ ...,\ x_n \mapsto t_n],\ c \rangle \vdash^{\Gamma}_{stmt}\ s$}
        \RL{\textsc{T-Method}}
        \UIC{$\langle \Pi, c \rangle \vdash^{\Gamma}_{meth}\ \textbf{method}\ q(t_1 x_1,\ ...,\ t_n x_n)\ s$}
        \DP

        \vskip 2em

        % Class
        \AXC{$\Gamma(c) = \Big( \overbrace{\big\{ \langle t_1, f_1 \rangle,\ ...,\ \langle t_i, f_i \rangle \big\}}^{fields},\ \overbrace{\{ m_1,\ ...,\ m_n \}}^{methods} \Big)$}
        \DP
        \AXC{$\Pi = \big[ f_1 \mapsto t_1,\ ...,\ f_n \mapsto t_n \big]$}
        \AXC{$\langle \Pi, c \rangle \vdash^{\Gamma}_{meth}\ m_1 \quad \cdots \quad \langle \Pi, c \rangle \vdash^{\Gamma}_{meth}\ m_n$}
        \RL{\textsc{T-Class}}
        \BIC{$\vdash^{\Gamma}_{class}\ c$}
        \DP

        \vskip 2em

        \AXC{$\Big( \textbf{method main ()}\ s \Big) \in \displaystyle\bigcup^{n}_{i = 1} \text{methods}(c_i)$}
        \DP
        \AXC{$\Gamma = \text{gen}(c_1,\ ...,\ c_n)$}
        \AXC{$\vdash^{\Gamma}_{class}\ c_1 \quad \cdots \quad \vdash^{\Gamma}_{class}\ c_n$}
        \RL{\textsc{T-Prog}}
        \BIC{$\vdash_{prog}\ c_1\ \cdots\ c_n$}
        \DP
    \end{center}
    \caption{Typing rules for class methods, classes and programs}
    \label{fig:typing-programs}
\end{figure}

\section{Language Semantics}
\label{sec:language-semantics}
% TODO:
blabla

\subsection{Preliminaries}
\label{subsec:semantics-preliminaries}
% TODO:
blabla

\begin{figure}[ht]
    \begin{alignat*}{2}
        l      \in\ &\text{Locs}     &&= \mathbb{N}_0\\
        \gamma \in\ &\text{Envs}     &&= \text{VarIDs} \rightharpoonup \text{Locs}\\
        \mu    \in\ &\text{Stores}   &&= \text{Locs} \rightharpoonup \text{Values}\\
        &\text{Objects} &&= \Big\{ \langle c_f,\ \gamma_f \rangle \mid c_f \in \text{ClassIDs}\ \wedge\ \gamma_f \in \text{Envs} \Big\}\\
        v \in\ &\text{Values} &&= \mathbb{Z} \cup \text{Objects}\ \cup \text{Locs}
    \end{alignat*}
    \caption{Semantic values}
    \label{fig:semantic-values}
\end{figure}

\subsection{Expressions}
\label{subsec:semantics-expressions}
The judgment:
\begin{prooftree}
    \AXC{$\langle \gamma, \mu \rangle \vdash_{expr}\ e \Rightarrow v$}
\end{prooftree}
defines the meaning of expressions. We say that under environment $\gamma$ and store $\mu$, expression $e$ evaluates to value $v$.

\begin{figure}[ht]
    \begin{center}
        \AXC{}
        \RL{\textsc{Con}}
        \UIC{$\langle \gamma, \mu \rangle \vdash_{expr}\ n \Rightarrow \bar{n}$}
        \DP
        \hskip 1.5em
        \AXC{}
        \RL{\textsc{Var}}
        \UIC{$\langle \gamma, \mu \rangle \vdash_{expr}\ x \Rightarrow \mu\Big( \gamma(x) \Big)$}
        \DP
        \hskip 1.5em
        \AXC{}
        \RL{\textsc{Nil}}
        \UIC{$\langle \gamma, \mu \rangle \vdash_{expr}\ \texttt{\textbf{nil}} \Rightarrow 0$}
        \DP

        \vskip 1.5em

        \AXC{$\langle \gamma, \mu \rangle \vdash_{expr}\ e_1 \Rightarrow v_1 $}
        \AXC{$\langle \gamma, \mu \rangle \vdash_{expr}\ e_2 \Rightarrow v_2 $}
        \AXC{$\llbracket \otimes \rrbracket(v_1, v_2) = v$}
        \RL{\textsc{BinOp}}
        \TIC{$\langle \gamma, \mu \rangle \vdash_{expr}\ e_1 \otimes e_2 \Rightarrow v$}
        \DP 
    \end{center}
    \caption{Semantic inference rules for expressions}
    \label{fig:semantics-expr-rules}
\end{figure}

% TODO: write
blabla

\begin{figure}[ht]
    \begin{align*}
        &\llbracket \texttt{\textbf{+}} \rrbracket (v_1, v_2) &&= v_1 + v_2 &\llbracket \texttt{\textbf{\%}} \rrbracket (v_1, v_2)      &&&= v_1\ \text{mod}\ v_2\\
        &\llbracket \texttt{\textbf{-}} \rrbracket (v_1, v_2) &&= v_1 - v_2 &\llbracket \texttt{\textbf{\&}} \rrbracket (v_1, v_2)       &&&= v_1 \wedge v_2\\
        &\llbracket \texttt{\textbf{*}} \rrbracket (v_1, v_2) &&= v_1 \times v_2 &\llbracket \texttt{\textbf{|}} \rrbracket  (v_1, v_2) &&&= v_1 \vee v_2\\
        &\llbracket \texttt{\textbf{/}} \rrbracket (v_1, v_2) &&= v_1 \div v_2 &\llbracket \texttt{\textbf{\^}} \rrbracket (v_1, v_2)   &&&= v_1 \oplus v_2\\ 
        &\llbracket\texttt{\textbf{\&\&}}\rrbracket (v_1, v_2) &&= \begin{cases} 
            0 & \text{if}\ v_1 = 0 \vee v_2 = 0\\ 
            1 & \text{otherwise}
        \end{cases}        
        &\llbracket\texttt{\textbf{<=}}\rrbracket (v_1, v_2) &&&= \begin{cases} 
            0 & \text{if}\ v_1 \leq v_2\\ 
            1 & \text{otherwise} 
        \end{cases}\\
        &\llbracket\texttt{\textbf{||}}\rrbracket (v_1, v_2) &&= \begin{cases}
            0 & \text{if}\ v_1 = v_2 = 0\\ 
            1 & \text{otherwise}
        \end{cases}
        &\llbracket\texttt{\textbf{>=}}\rrbracket (v_1, v_2) &&&= \begin{cases}
            0 & \text{if}\ v_1 \geq v_2\\
            1 & \text{otherwise}
        \end{cases}\\
        &\llbracket\texttt{\textbf{<}}\rrbracket (v_1, v_2) &&= \begin{cases}
            0 & \text{if}\ v_1 < v_2\\ 
            1 & \text{otherwise}
        \end{cases}
        &\llbracket\texttt{\textbf{=}}\rrbracket (v_1, v_2) &&&= \begin{cases}
            0 & \text{if}\ v_1 = v_2\\
            1 & \text{otherwise}
        \end{cases}\\
        &\llbracket\texttt{\textbf{>}}\rrbracket (v_1, v_2) &&= \begin{cases}
            0 & \text{if}\ v_1 > v_2\\ 
            1 & \text{otherwise}
        \end{cases}
        &\llbracket\texttt{\textbf{!=}}\rrbracket (v_1, v_2) &&&= \begin{cases}
            0 & \text{if}\ v_1 \not= v_2\\
            1 & \text{otherwise}
        \end{cases}
    \end{align*} 
    \caption{Definition of binary expression operator evaluation}
\end{figure}

blabla

\subsection{Statements}
\label{subsec:semantics-statements}
The judgment
\begin{prooftree}
    \AXC{$\langle l, \gamma \rangle \vdash^{\Gamma}_{stmt}\ s : \mu \rightleftharpoons \mu'$}
\end{prooftree}
defines the meaning of statements. We say that under environment $\gamma$ and object $l$, statement $s$ with class map $\Gamma$ reversibly transforms store $\mu$ to store $\mu'$. 
blabla

\begin{figure}[H]
    \begin{center}
        % Skip
        \AXC{}
        \RL{\textsc{Skip}}
        \UIC{$\langle l, \gamma \rangle \vdash^{\Gamma}_{stmt}\ \textbf{skip} : \mu \rightleftharpoons \mu'$}
        \DP

        \vskip 2em

        % Seq
        \AXC{$\langle l, \gamma \rangle \vdash^{\Gamma}_{stmt}\ s_1 : \mu \rightleftharpoons \mu'$}
        \AXC{$\langle l, \gamma \rangle \vdash^{\Gamma}_{stmt}\ s_2 : \mu' \rightleftharpoons \mu''$}
        \RL{\textsc{Seq}}
        \BIC{$\langle l, \gamma \rangle \vdash^{\Gamma}_{stmt}\ s_1\ s_2 : \mu \rightleftharpoons \mu''$}
        \DP

        \vskip 2em

        % AssVar
        \AXC{$\langle \gamma, \mu \rangle \vdash^{\Gamma}_{stmt}\ e \Rightarrow v$}
        \AXC{$\llbracket \odot \rrbracket \Big( \mu \Big( \gamma(x) \Big), v \Big) = v'$}
        \RL{\textsc{AssVar}}
        \BIC{$\langle l, \gamma \rangle \vdash^{\Gamma}_{stmt}\ x \odot= e\ :\ \mu \rightleftharpoons \mu[\gamma(x) \mapsto v']$}
        \DP

        \vskip 2em

        % SwpVar
        \AXC{$\mu \Big( \gamma(x_1) \Big) = v_1$}
        \AXC{$\mu \Big( \gamma(x_2) \Big) = v_2$}
        \RL{\textsc{SwpVar}}
        \BIC{$\langle l, \gamma \rangle \vdash^{\Gamma}_{stmt}\ x_1\ \texttt{\textbf{<=>}}\ x_2\ :\ \mu \rightleftharpoons \mu[\gamma(x_1) \mapsto v_2,\ \gamma(x_2) \mapsto v_1]$}
        \DP

        \vskip 2em

        % Loop Main
        \AXC{$\langle \gamma, \mu \rangle \vdash^{\Gamma}_{expr}\ e_1 \not\Rightarrow 0$}
        \AXC{$\langle l, \gamma \rangle \vdash^{\Gamma}_{stmt}\ s_1 : \mu \rightleftharpoons \mu'$}
        \AXC{$\langle l, \gamma \rangle \vdash^{\Gamma}_{loop}\ (e_1, s_1, s_2, e_2) : \mu' \rightleftharpoons \mu''$}
        \RL{\textsc{LoopMain}}
        \TIC{$\langle l, \gamma \rangle \vdash^{\Gamma}_{stmt}\ \textbf{from}\ e_1\ \textbf{do}\ s_1\ \textbf{loop}\ s_2\ \textbf{until}\ e_2\ :\ \mu \rightleftharpoons \mu''$}
        \DP

        \vskip 2em

        % Loop Base
        \AXC{$\langle \gamma, \mu \rangle \vdash^{\Gamma}_{expr}\ e_2 \not\Rightarrow 0$}
        \RL{\textsc{LoopBase}}
        \UIC{$\langle l, \gamma \rangle \vdash^{\Gamma}_{loop}\ (e_1, s_1, s_2, e_2)\ :\ \mu \rightleftharpoons \mu$}
        \DP

        \vskip 2em

        % Loop Rec
        \AXC{$\langle \gamma, \mu \rangle \vdash^{\Gamma}_{expr} e_2 \Rightarrow 0$}
        \DP
        \hskip 8em
        \AXC{$\langle l, \gamma \rangle \vdash^{\Gamma}_{stmt} s_2 : \mu \rightleftharpoons \mu'$}
        \DP
        \vskip 0.5em
        \AXC{$\langle \gamma, \mu' \rangle \vdash^{\Gamma}_{expr} e_1 \Rightarrow 0$}
        \AXC{$\langle l, \gamma \rangle \vdash^{\Gamma}_{stmt} s_1 : \mu' \rightleftharpoons \mu''$}
        \AXC{$\langle l, \gamma \rangle \vdash^{\Gamma}_{loop} (e_1, s_1, s_2, e_2) : \mu'' \rightleftharpoons \mu'''$}
        \RL{\textsc{LoopRec}}
        \TIC{$\langle l, \gamma \rangle \vdash^{\Gamma}_{loop}\ (e_1, s_1, s_2, e_2)\ :\ \mu \rightleftharpoons \mu'''$}
        \DP

        \vskip 2em

        % If True
        \AXC{$\langle \gamma, \mu \rangle \vdash^{\Gamma}_{expr} e_1 \not\Rightarrow 0$}
        \AXC{$\langle l, \gamma \rangle \vdash^{\Gamma}_{stmt} s_1 : \mu \rightleftharpoons \mu'$}
        \AXC{$\langle \gamma, \mu' \rangle \vdash^{\Gamma}_{expr} e_2 \not\Rightarrow 0$}
        \RL{\textsc{IfTrue}}
        \TIC{$\langle l, \gamma \rangle \vdash^{\Gamma}_{stmt}\ \textbf{if}\ e_1\ \textbf{then}\ s_1\ \textbf{else}\ s_2\ \textbf{fi}\ e_2\ :\ \mu \rightleftharpoons \mu'$}
        \DP

        \vskip 2em

        % If False
        \AXC{$\langle \gamma, \mu \rangle \vdash^{\Gamma}_{expr} e_1 \Rightarrow 0$}
        \AXC{$\langle l, \gamma \rangle \vdash^{\Gamma}_{stmt} s_1 : \mu \rightleftharpoons \mu'$}
        \AXC{$\langle \gamma, \mu' \rangle \vdash^{\Gamma}_{expr} e_2 \Rightarrow 0$}
        \RL{\textsc{IfFalse}}
        \TIC{$\langle l, \gamma \rangle \vdash^{\Gamma}_{stmt}\ \textbf{if}\ e_1\ \textbf{then}\ s_1\ \textbf{else}\ s_2\ \textbf{fi}\ e_2\ :\ \mu \rightleftharpoons \mu'$}
        \DP

        \vskip 2em

        % Call
        \AXC{$\mu(l) = \langle c, \gamma' \rangle $}
        \DP
        \AXC{$\Gamma(c) = (fields, methods)$}
        \DP
        \AXC{$\Big( \textbf{method}\ q(t_1 y_1,\ ...,\ t_n y_n)\ s \Big) \in methods$}
        \DP
        \AXC{$\Big\langle l, \gamma'[y_1 \mapsto \gamma(x_1),\ ...,\ y_n \mapsto \gamma(x_n)] \Big\rangle \vdash^{\Gamma}_{stmt}\ s : \mu \rightleftharpoons \mu'$}
        \RL{\textsc{Call}}
        \UIC{$\langle l, \gamma \rangle \vdash^{\Gamma}_{stmt}\ \textbf{call}\ q(x_1,\ ...,\ x_n)\ :\ \mu \rightleftharpoons \mu'$}
        \DP

        \vskip 2em

        % Uncall
        \AXC{$\langle l, \gamma \rangle \vdash^{\Gamma}_{stmt}\ \textbf{call}\ q(x_1,\ ...,\ x_n)\ :\ \mu' \rightleftharpoons \mu$}
        \RL{\textsc{Uncall}}
        \UIC{$\langle l, \gamma \rangle \vdash^{\Gamma}_{stmt}\ \textbf{uncall}\ q(x_1,\ ...,\ x_n)\ :\ \mu \rightleftharpoons \mu'$}
        \DP
    \end{center}
    \caption{Semantic inferance rules for statements}
    \label{fig:semantic-statements}
\end{figure}

\begin{figure}[H]
    \begin{center}
        \AXC{$l' = \mu\Big( \gamma(x_0) \Big) $}
        \DP
        \AXC{$\mu(l') = \langle c, \gamma' \rangle $}
        \DP
        \AXC{$\Gamma(c) = (fields, methods)$}
        \DP
        \AXC{$\Big( \textbf{method}\ q(t_1 y_1,\ ...,\ t_n y_n)\ s \Big) \in methods$}
        \DP
        \AXC{$\Big\langle l', \gamma'[y_1 \mapsto \gamma(x_1),\ ...,\ y_n \mapsto \gamma(x_n)] \Big\rangle \vdash^{\Gamma}_{stmt}\ s : \mu \rightleftharpoons \mu'$}
        \RL{\textsc{CallObj}}
        \UIC{$\langle l, \gamma \rangle \vdash^{\Gamma}_{stmt}\ \textbf{call}\ x_0::q(x_1,\ ...,\ x_n)\ :\ \mu \rightleftharpoons \mu'$}
        \DP

        \vskip 2em
        
        % Object Uncall
        \AXC{$\langle l, \gamma \rangle \vdash^{\Gamma}_{stmt}\ \text{call}\ x_0::q(x_1,\ ...,\ x_n)\ :\ \mu' \rightleftharpoons \mu$}
        \RL{\textsc{ObjUncall}}
        \UIC{$\langle l, \gamma \rangle \vdash^{\Gamma}_{stmt}\ \text{uncall}\ x_0::q(x_1,\ ...,\ x_n)\ :\ \mu \rightleftharpoons \mu'$}
        \DP

        \vskip 2em

        % Object block
        \AXC{$\Gamma(c) = \Big( \overbrace{\{\langle t_1, f_1 \rangle,\ ...,\ \langle t_n, f_n \rangle \}}^{fields}, methods \Big)$}
        \DP
        \AXC{$\gamma' = [f_1 \mapsto a_1,\ ...,\ f_n \mapsto a_n]$}
        \DP
        \vskip 1em
        \AXC{$\{ l', r, a_1, ..., a_n \} \cap \text{dom}(\mu) = \emptyset$}
        \DP
        \AXC{$|\{ l', r, a_1, ..., a_n \}| = n + 2$}
        \DP
        \vskip 1em
        \AXC{$\mu' = \mu\Big[ a_1 \mapsto 0,\ ...,\ a_n \mapsto 0,\ l' \mapsto \langle c, \gamma' \rangle,\ r \mapsto l' \Big]$}
        \DP
        \vskip 1em
        \AXC{$\langle l, \gamma[x \mapsto r] \rangle \vdash^{\gamma}_{stmt}\ s : \mu' \rightleftharpoons \mu''$}
        \AXC{$\mu''(a_1) = 0\ \cdots\ \mu''(a_n) = 0$}
        \RL{\textsc{ObjBlock}}
        \BIC{$\langle l, \gamma \rangle \vdash^{\Gamma}_{stmt}\ \textbf{construct}\ c\ x \quad s \quad \textbf{destruct}\ x\ :\ \mu \rightleftharpoons \mu'' \upharpoonright_{\text{dom}(\mu)}$}  
        \DP

        % TODO: ObjNew ObjDlt, Copy Uncopy
    \end{center}
    \caption{Semantic inferance rules for statements (cont)}
    \label{fig:semantic-statements-cont}
\end{figure}
% TODO: Explain previous figs
blalbalba 


\subsection{Programs}
\label{subsec:semantics-programs}
The judgment
\begin{prooftree}
    \AXC{$\vdash_{prog} p \Rightarrow \sigma$}
\end{prooftree}
defines the meaning of programs. The class $p$ containing the main method is instantiated and the main function is executed with the partial function $\sigma$ as the result, mapping variable identifiers to values, correlating to the class fields of the main class.

\begin{figure}[ht]
    \begin{center}
        
        \AXC{$\Gamma = \text{gen}(c_1,\ ...,\ c_n)$}
        \DP
        \AXC{$\Gamma(c) = \Big( \overbrace{\{ \langle t_1, f_1 \rangle,\ ...,\ \langle t_n, f_n \rangle \}}^{fields},\ methods \Big)$}
        \DP
        \AXC{$\Big( \textbf{method main ()}\ s \Big) \in methods$}
        \DP
        \AXC{$\gamma = [f_1 \mapsto 1,\ ...,\ f_i \mapsto i]$}
        \DP
        \AXC{$\mu = [1 \mapsto 0,\ ...,\ i \mapsto 0,\ i+1 \mapsto \langle c, \gamma \rangle]$}
        \AXC{$\langle i+1, \gamma \rangle \vdash^{\Gamma}_{stmt}\ s\ :\ \mu \rightleftharpoons \mu'$}
        \RL{\textsc{Main}}
        \BIC{$\vdash_{prog}\ c_1\ \cdots\ c_n \Rightarrow (\mu' \circ \gamma)$}
        \DP
    \end{center}
    \caption{Semantic inference rules for programs}
    \label{fig:semantics-programs}
\end{figure}
blabla


\section{Program Inversion}
\label{sec:program-inversion}

\section{Computational Strength}
\label{sec:computational-strength}
Traditional, non-reversible programming languages have their computational strength measured in terms of their abilities to simulate the Turing machine (TM). If any arbitrary Turing machine can be implemented in some programming language, the language is said to be computationally universal or Turing-complete. In essence, Turing-completeness marks when a language can compute all computable functions. Reversible programming languages, like \textsc{Janus}, \textsc{Roopl} and \rooplpp, are not Turing-complete as they only are capable of computing injective, computable functions.

For determining computing strength of reversible programming languages,~\citeauthor{ty:ejanus} suggests that the reversible Turing machine (RTM) could serve as the baseline criterion~\cite{ty:ejanus}. As such, if a reversible programming language is reversibly universal or r-Turing complete if it is able to simulate a reversible Turing machine cleanly, i.e. without generating garbage data. If garbage was left on the tape, the function simulated by the machine would not be an injective function and as such, no garbage should be left after termination of the simulation.

\subsection{Reversible Turing Machines}
\label{subsec:reversible-turing-machine}
Before we show that \rooplpp in fact is r-Turing complete, we present the formalized reversible Turing machine definition, as used in~\cite{ty:ejanus}.
\vspace{4mm}
\begin{definition}
    \label{def:quadruple-tm}(Quadruple Turing Machine)\vspace{4mm}\\
    \noindent A TM T is a tuple $(Q,\ \Gamma,\ b,\ \delta,\ q_s,\ q_f)$ where
    %
    \begin{itemize}[label = {}, itemsep = 1pt]
        \item $Q$ is the finite non-empty set of states
        \item $\Gamma$ is the finite non-empty set of tape alphabet symbols
        \item $b\ \in\ \Gamma$ is the blank symbol
        \item $\delta\ :\ (Q\ \times\ \Gamma\ \times\ \Gamma\ \times\ Q)\ \cup\ (Q\ \times\ \{/\}\ \times\ \{L,\ R\}\ \times\ Q)$ is the partial function representing the transitions
        \item $q_s\ \in\ Q$ is the starting state
        \item $q_f\ \in\ Q$ is the final state
    \end{itemize}
    %
    The symbols $L$ and $R$ represent the tape head shift-directions left and right. A quadruple is either a symbol rule of the form $(q_1,\ s_1,\ s_2,\ q_2)$ or a shift rule of the form $(q_1,\ /,\ d,\ q_2)$ where $q_1 \in Q$, $q_2 \in Q$, $s_1 \in \Gamma$, $s_2 \in \Gamma$ and $d$ being either $L$ or $R$.
    
    A symbol rule $(q_1,\ s_1,\ s_2,\ q_2)$ means that in state $q_1$, when reading $s_1$ from the tape, write $s_2$ to the tape and change to state $q_2$. A shift rule $(q_1,\ /,\ d,\ q_2)$ means that in state $q_1$, move the tape head in direction $d$ and change to state $q_2$.
\end{definition}
\vspace{4mm}
\begin{definition}
    \label{def:reversible-tm}(Reversible Turing Machine)\vspace{4mm}\\
    \noindent A TM T is a reversible TM iff, for any distinct pair of quadruples $(q_1,\ s_1,\ s_2,\ q_2)\ \in\ \delta_T$ and $(q'_1,\ s'_1,\ s'_2,\ q'_2)\ \in\ \delta_T$, we have
    %
    \begin{itemize}[label = {}, itemsep = 1pt]
        \item $q_1\ =\ q'_1\ \implies\ (t_1\ \neq\ / \quad \wedge \quad t'_1\ \neq\ / \quad \wedge \quad t_1\ \neq\ t'_1)$ (forward determinism)
        \item $q_2\ =\ q'_2\ \implies\ (t_1\ \neq\ / \quad \wedge \quad t'_1\ \neq\ / \quad \wedge \quad t_2\ \neq\ t'_2)$ (backward determinism)
    \end{itemize}
\end{definition}

\citeauthor{th:roopl} describe a RTM simulation implemented in \textsc{Roopl} by representing the set of states $\{q_1,\ \dots,\ q_n\}$ and the tape alphabet $\Gamma$ as integers and the rule $/$ and direction symbols $L$ and $R$ as the uppercase integer literals \inst{SLASH}, \inst{LEFT} and \inst{RIGHT}. As \textsc{Roopl} contains no array or stack primitives, the transition table $\delta$ was suggested to be represented as a linked list of objects containing four integers ${\textbf{q1}}$, ${\textbf{s1}}$, ${\textbf{s2}}$ and ${\textbf{q2}}$ each, where ${\textbf{s1}}$ equals \inst{SLASH} for shift rules. In \rooplpp, we do, however, has an array primitive and as such, we can simply simulate transitions, by having rules ${\textbf{q1}}$, ${\textbf{s1}}$, ${\textbf{s2}}$ and ${\textbf{q2}}$ represented as arrays, where the number of cells in each array is \inst{PC\_MAX}, in a similar fashion as in~\cite{ty:ejanus}.

\subsection{Tape Representation}
\label{subsec:tape-representation}
As with regular Turing machines, the tape of the machine is of infinite length. Therefore, we must simulate tape growth in either direction.
\citeauthor{ty:ejanus} represented the tape using two stack primitives in the Janus RTM interpreter and \citeauthor{th:roopl} used list of objects. In \rooplpp, we could implement a stack, as objects are not statically scoped as in \textsc{Roopl}. However, in terms of easy of use, a linked-list implementation, of simple objects containing a \textit{value} and \textit{next} field, is more intuitive.

As such, the cell index which the tape head currently hovers over is represented by an integer variable, which simply is the index into the linked list of tape cells. At the end of each simulated step of the RTM, the position of the tape head variable is bounds-checked to determine if the tape head has moved off the current tape length to either the left or the right. In either case, a new cell is allocated and prepended to the linked list, if the tape head moved off the tape to the left and appended to the linked list, if the tape head moved off the tape to the right. Thus allowing the tape to grow unboundedly in either direction.

\subsection{Reversible Turing Machine Simulation}
\label{subsec:rtm-simulation}
Figure~\ref{fig:rtm-instruction-method} shows the modified method \textit{inst} from~\cite{ty:ejanus}, which executes a single instruction given a the current state, symbol, program counter and the four arrays representing the transition rules. 

\begin{figure}[ht]
    % TODO: Fix referencing
    \centering
    \begin{lstlisting}[style = basic, language = roopl]
    method inst(int state, int symbol, int q1[], int s1[], int s2[], int q2[], int pc)
        if (state = q1[pc]) && (symbol = s1[pc]) then   // Symbol rule:
            state += q2[pc]-q1[pc]                      // set state to q2[pc]
            symbol += s2[pc]-s1[pc]                     // set symbol to s2[pc]
        fi (state = q2[pc]) && (symbol = s2[pc])
        if (state = q1[pc]) && (s1[pc] = SLASH) then    // Move rule:
            state += q2[pc]-q1[pc]                      // set state to q2[pc]
            if s2[pc] = RIGHT then
                pos += 1                                // Move tape head right
            fi s2[pc] = RIGHT
            if s2[pc] = LEFT then
                pos -= 1                                // Move tape head left
            fi s2[pc] = LEFT
        fi (state = q2[pc]) && (s1[pc] = SLASH)
    \end{lstlisting}
    \caption{Method for executing a single TM transition}
    \label{fig:rtm-instruction-method}
\end{figure}

Figure~\ref{fig:rtm-simulation-method} shows the simulate method which is the main method responsible for running the RTM simulation. The tape is extended in either direction when needed and the program counter it incremented.

Unlike the \textsc{Roopl} simulation, \rooplpp is not limited by stack allocated, statically-scoped objects. Due to this limitation, the \textsc{Roopl} RTM simulator cannot finish with the TM tape as its program output when the RTM halts, as the call stack of the simulation must unwind before termination. As \rooplpp has dynamically-scoped objects, this limitation is lifted and as such, the TM tape will exist as the program out when the RTM halts.

\begin{figure}[ht]
    \centering
    \begin{lstlisting}[style = basic, language = roopl]
    method simulate(Cell tape, int pos, int state, int q1[], 
                    int s1[], int s2[], int q2[], int pc)
        local int len = 0
        call tape::length(len)                                  //Calculate length of tape

        if pos > len then                                       //Append new tape cell
            new Cell cell(BLANK, empty)
            call tape::insert(pos, len, cell)
            call simulate(                                      //Continue simulation
            Cell tape, int pos, int state, int q1[], 
            int s1[], int s2[], int q2[], int pc) 
        else
            if pos < 0 then                                     //Prepend new tape cell
                new Cell cell(BLANK, tape)
                tape <=> cell
                pos += 1
                call simulate(                                  //Continue simulation
                    Cell tape, int pos, int state, int q1[], 
                    int s1[], int s2[], int q2[], int pc)         
            else
                call incrementPc(pc, PC_MAX)                    //Increment pc
                local int symbol = 0
                call tape::lookup(pos, symbol)                  //Fetch current symbol
                call inst(state, symbol, q1, s1, s2, q2, pc)
                uncall tape::lookup(pos, symbol)                //Zero-clear symbol    
                delocal symbol = 0
                             
                if state = Qf then                              //If RTM simulation is finished
                    call tape::get(result)                      //Copy result of simulation
                else
                    call simulate(                              //Continue simulation
                        Cell tape, int pos, int state, int q1[], 
                        int s1[], int s2[], int q2[], int pc)     
                fi state = Qf
            fi pos < 0
        fi pos > len

        uncall tape::length(len)                                //Clear length of tape
        delocal len = 0
    \end{lstlisting}
    \caption{Main RTM simulation method}
    \label{fig:rtm-simulation-method}
\end{figure} 

