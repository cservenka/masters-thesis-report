\chapter{Compilation}
\label{chp:compilation}
The following chapter presents the considerations and translation schemas used in the process of translating \rooplpp to the reversible low-level machine language \textsc{Pisa}. As \rooplpp is a continuation of \textsc{Roopl}, many techniques are carried directly over and have a such been left out.

\section{The \textsc{Roopl} to \textsc{Pisa} compiler}
\label{sec:roopl-to-pisa-compiler}
\citeauthor{th:roopl} presented a proof-of-concept compiler along with the design for \textsc{Roopl}. The compiler translates well-typed \textsc{Roopl} programs into the reversible machine language \textsc{Pisa}.

Figure~\ref{fig:roopl-memory-layout} shows the memory layout of a compiled \textsc{Roopl} program. The layout consists of a static storage segment, the program segment and the stack. 
\begin{figure}[ht]
    \centering
    \begin{tikzpicture}
        \fill[fill = grey] (6, 0) rectangle (8, 3) node[midway] {Stack};
        \draw (6, 0) -- (12, 0);
        \draw (6, 3) -- (12, 3);
        \draw (12, 0) -- (12, 3);
        \draw[dashed] (8, 0) -- (8, 3);
    
        \filldraw[fill = grey, draw = black] (0, 0) rectangle (2.5, 3) node[midway] {Static Data};
        \filldraw[fill = darkgrey, draw = black] (2.5, 0) rectangle (6, 3) node[midway] {Program};
        
        \node at (10, 2.5) {(unused memory)};
        \node at (0, -.3) {$0$};
        \node at (6, -.3) {$p$};
        \node at (8, -.3) {$sp$};
        \node at (12, -.3) {$2^{31} - 1$};
        \node at (6, -1) {$\longleftarrow$ Address Space $\longrightarrow$};
        \draw[arrow, dashed] (8, 1.5) -- (10, 1.5);
        \node at (8.9, 1.2) {\scriptsize{\textit{stack grows}}};
    \end{tikzpicture}
    \caption{Memory layout of a \textsc{Roopl} program}
    \label{fig:roopl-memory-layout}
\end{figure}

\section{\rooplpp Memory Layout}
\label{sec:rooplpp-memory-layout}
\rooplpp builds upon its predecessor's memory layout with dynamic memory management. The reversible Buddy Memory heap layout presented in section~\ref{subsec:buddy-memory} is utilized in \rooplpp as it is an interesting layout, naturally translates into a reversible setting with one simple restriction (i.e only blocks which are heads of their respectable free lists are allocatable) and since its only drawback is dismissible in most real world scenarios.

Figure~\ref{fig:memory-layout} shows the full layout of a \rooplpp program stored in memory.

\begin{itemize}
    \item As with \textsc{Roopl}, the static storage segment contains load-time labelled \inst{data} instructions, initialized with virtual function tables and other static data needed by the translated program.

    \item The program segment is stored right after the static storage and contains the translate \rooplpp program instructions.

    \item The free lists maintained by the Buddy Memory heap layout is placed right after the program segment, with the \textit{free list pointer} $flp$ pointing at the first free list. The free lists are simple the address to the first block of its respective size. The free lists are stores such that the free list at address $flp + i$ corresponds to the free list of size $2^{i+1}$.   

    \item The heap begins directly following the free lists. Its beginning is marked by the \textit{heap pointer} $(hp)$. 

    \item Unlike in \textsc{Roopl}, where the stack grows upwards, the \rooplpp stack grows downwards and is begins at address $p$. The stack remains a LIFO structure, analogously to \textsc{Roopl}.
\end{itemize}

As denoted in the previous chapter, we assume an underlying reversible operating system providing us with additional memory when needed. With no real way of simulating this, the \rooplpp compiler places the stack at a fixed address $p$ and sets one free block in the largest $2^n$ free list initially. The number of free lists and the address $p$ is configurable in the source code, but is defaulted to $10$ free lists, meaning initially one block of size $1024$ is available and the stack is placed at address $2048$.

In traditional compilers, the heap pointer usually points to the end of the heap. For reasons stated above, we never grow the heap as we start with a heap of fixed size. As such, the heap pointer simply points to the beginning of the heap.

\begin{figure}[ht]
    \centering
    \begin{tikzpicture}
        \fill[fill = grey] (0, 0) rectangle (2.5, 3) node[midway] {Static Data};
        \fill[fill = darkgrey] (2.5, 0) rectangle (5, 3) node[midway] {Program};
        \fill[fill = grey] (5, 0) rectangle (7, 3) node[midway] {Free lists};
        \fill[fill = grey] (7, 0) rectangle (8.5, 3) node[midway] {Heap};
        \fill[fill = grey] (12.5, 0) rectangle (14, 3) node[midway] {Stack}; 
        
        \draw (0, 0) -- (15, 0);
        \draw (0, 3) -- (15, 3);
        \draw (0, 0) -- (0, 3);
        \draw (15, 0) -- (15, 3);
        \draw (2.5, 0) -- (2.5, 3);
        \draw (5, 0) -- (5, 3); 
        \draw (7, 0) -- (7, 3);
        \draw (14, 0) -- (14, 3); 
        \draw[dashed] (8.5, 0) -- (8.5, 3); 
        \draw[dashed] (12.5, 0) -- (12.5, 3);   
    
        \node at (10.5, 2.5) {(unused memory)};
        \node at (0, -.3) {$0$};
        \node at (5, -.3) {$flp$};
        \node at (7, -.3) {$hp$};
        \node at (14, -.3) {$p$};
        \node at (12.5, -.3) {$sp$};
        \node at (15, -.3) {$2^{31} - 1$};
        \node at (7.5, -1) {$\longleftarrow$ Address Space $\longrightarrow$};

        \draw[arrow, dashed] (8.5, 1.5) -- (10.1, 1.5);
        \node at (9.4, 1.2) {\scriptsize{\textit{heap grows}}};

        \draw[arrow, dashed] (12.5, 1.5) -- (10.9, 1.5); 
        \node at (11.6, 1.2) {\scriptsize{\textit{stack grows}}};
    \end{tikzpicture}
    \caption{Memory layout of a \rooplpp program}
    \label{fig:memory-layout}
\end{figure}

\section{Inherited \textsc{Roopl} features}
\label{sec:inherited-features}
As mentioned, a number of features from \textsc{Roopl} carries over in \rooplpp.

The dynamic dispatching mechanism presented in~\cite{th:roopl} is inherited. As such, the invocation of a method implementation is based on the type of the object at run time. Virtual function tables are still the implementation strategy used in the dynamic dispatching implementation.

Evaluation of expressions and control flow remains unchanged. 

For completeness, object blocks are included and still stack allocated as their life time is limited to the scope of their block and the dynamic allocation process is quite expensive in terms of register pressure and number of instructions compared to the stack allocated method presented implemented in the \textsc{Roopl} compiler.

The object layout remains unchanged (\textit{for now, until reference counting is added}) and is shown in figure~\ref{fig:object-layout}

\begin{figure}[h]
    \centering
    
    \begin{subfigure}[t]{.32\textwidth}
        \vskip 0pt
        \centering
        \begin{tikzpicture}
            \draw[dashed] (0, 1.5) -- (0, 2);
            \draw[dashed] (3, 1.5) -- (3, 2);
            \filldraw[fill = grey, draw = black] (0, 1) rectangle (3, 1.5) node[midway] {addr(vtable)};
            \filldraw[fill = darkgrey, draw = black] (0, .5) rectangle (3, 1) node[midway] {x};
            \filldraw[fill = grey, draw = black] (0, 0) rectangle (3, .5) node[midway] {y};
            \draw[dashed] (0, 0) -- (0, -.5);
            \draw[dashed] (3, 0) -- (3, -.5);
    
            \node at (-.3, 1.25) {\texttt{+}$0$};
            \node at (-.3, .75) {\texttt{+}$1$};
            \node at (-.3, .25) {\texttt{+}$2$};
            \draw[->] (3.5, 1.25) -- (3.1, 1.25);
            \node[rotate = 270] at (3.7, 1.25) {$r_{shape}$};
            
            \node at (1.5, 2.5) {\textbf{Shape}};
        \end{tikzpicture}
    \end{subfigure}
    \begin{subfigure}[t]{.32\textwidth}
        \vskip 0pt
        \centering
        \begin{tikzpicture}
            \draw[dashed] (0, 1.5) -- (0, 2);
            \draw[dashed] (3, 1.5) -- (3, 2);
            \filldraw[fill = grey, draw = black] (0, 1) rectangle (3, 1.5) node[midway] {addr(vtable)};
            \filldraw[fill = darkgrey, draw = black] (0, .5) rectangle (3, 1) node[midway] {x};
            \filldraw[fill = grey, draw = black] (0, 0) rectangle (3, .5) node[midway] {y};
            \filldraw[fill = darkgrey, draw = black] (0, -.5) rectangle (3, 0) node[midway] {radius};
            \draw[dashed] (0, -.5) -- (0, -1);
            \draw[dashed] (3, -.5) -- (3, -1);
    
            \node at (-.3, 1.25) {\texttt{+}$0$};
            \node at (-.3, .75) {\texttt{+}$1$};
            \node at (-.3, .25) {\texttt{+}$2$};
            \node at (-.3, -.25) {\texttt{+}$3$};
            \draw[->] (3.5, 1.25) -- (3.1, 1.25);
            \node[rotate = 270] at (3.7, 1.25) {$r_{circ}$};
            
            \node at (1.5, 2.5) {\textbf{Circle}};
        \end{tikzpicture}
    \end{subfigure}
    \begin{subfigure}[t]{.32\textwidth}
        \vskip 0pt
        \centering
        \begin{tikzpicture}
            \draw[dashed] (0, 1.5) -- (0, 2);
            \draw[dashed] (3, 1.5) -- (3, 2);
            \filldraw[fill = grey, draw = black] (0, 1) rectangle (3, 1.5) node[midway] {addr(vtable)};
            \filldraw[fill = darkgrey, draw = black] (0, .5) rectangle (3, 1) node[midway] {x};
            \filldraw[fill = grey, draw = black] (0, 0) rectangle (3, .5) node[midway] {y};
            \filldraw[fill = darkgrey, draw = black] (0, -.5) rectangle (3, 0) node[midway] {a};
            \filldraw[fill = grey, draw = black] (0, -1) rectangle (3, -.5) node[midway] {b};
            \draw[dashed] (0, -1) -- (0, -1.5);
            \draw[dashed] (3, -1) -- (3, -1.5);
    
            \node at (-.3, 1.25) {\texttt{+}$0$};
            \node at (-.3, .75) {\texttt{+}$1$};
            \node at (-.3, .25) {\texttt{+}$2$};
            \node at (-.3, -.25) {\texttt{+}$3$};
            \node at (-.3, -.75) {\texttt{+}$4$};
            \draw[->] (3.5, 1.25) -- (3.1, 1.25);
            \node[rotate = 270] at (3.7, 1.25) {$r_{rect}$};
            
            \node at (1.5, 2.5) {\textbf{Rectangle}};
        \end{tikzpicture}
    \end{subfigure}
    
    \caption[Illustration of object memory layout]{Illustration of prefixing in the memory layout of 3 \rooplpp objects}
    \label{fig:object-layout}
    \end{figure}

\section{Program Structure}
\label{sec:program-structure}
The program structure of a translated \rooplpp is analogous to the program structure of a \textsc{Roopl} program with the addition of free lists and heap initialization. The full structure is shown in figure~\ref{fig:pisa-program-layout}. 

\begin{figure}[h]
    \centering

    \resizebox{.8\linewidth}{!}{
    \begin{minipage}{\linewidth}
    \begin{alignat*}{6}
    &\textbf{(1)}\quad&& &&\cdots\cdots && && &&\text{; Static data declarations}\\
    &\textbf{(2)}\quad&& &&\cdots\cdots && && &&\text{; Code for program class methods}\\
    &\textbf{(3)}\quad&&start\ \texttt{:}\quad&&\inst{start}\quad&& && &&\text{; Program starting point}\\
    &\textbf{(4)}\quad&& &&\inst{addi}\quad &&r_{flps}\quad &&p&&\text{; Initialize free lists pointer}\\
    &\textbf{(5)}\quad&& &&\inst{xor}\quad &&r_{hp}\quad &&r_{flps}\qquad &&\text{; Initialize heap pointer}\\
    &\textbf{(6)}\quad&& &&\inst{addi}\quad &&r_{hp}\quad &&size_{fls}&&\text{; Initialize heap pointer}\\
    &\textbf{(7)}\quad&& &&\inst{xor}\quad &&r_{b}\quad &&r_{hp}\qquad &&\text{; Store address of initial free  memory block in $r_b$}\\
    &\textbf{(8)}\quad&& &&\inst{ADDI}\quad &&r_{flps}\quad &&size_{fls}\quad &&\text{; Index to end of free    lists}\\
    &\textbf{(9)}\quad&& &&\inst{SUBI}\quad &&r_{flps}\quad && 1\quad &&\text{; Index to last element of free   lists}\\
    &\textbf{(10)}\quad&& &&\inst{EXCH}\quad &&rb\quad &&r_{flps}\quad &&\text{; Store address of first block in    last element of free lists}\\
    &\textbf{(11)}\quad&& &&\inst{ADDI}\quad &&r_{flps}\quad && 1\quad &&\text{; Index to end of free lists}\\
    &\textbf{(12)}\quad&& &&\inst{SUBI}\quad &&r_{flps}\quad &&s\quad &&\text{; Index to beginning of free lists}   \\
    &\textbf{(13)}\quad&& &&\inst{addi}\quad &&r_{sp}\quad &&offset_{stack}&&\text{; Initialize stack pointer}\\
    &\textbf{(14)}\quad&& &&\inst{xor}\quad &&r_m\quad &&r_{sp}\qquad &&\text{; Store address of main object in     $r_m$}\\
    &\textbf{(15)}\quad&& &&\inst{xori}\quad &&r_v\quad &&label_{vt}\qquad &&\text{; Store address of vtable in     $r_v$}\\
    &\textbf{(16)}\quad&& &&\inst{exch}\quad &&r_v\quad &&r_{sp}\qquad &&\text{; Push address of vtable onto    stack}\\
    &\textbf{(17)}\quad&& &&\inst{subi}\quad &&r_{sp}\quad &&size_m\qquad &&\text{; Allocate space for main     object}\\
    &\textbf{(18)}\quad&& &&\inst{push}\quad &&r_m\quad && &&\text{; Push '\textit{this}' onto stack}\\
    &\textbf{(19)}\quad&& &&\inst{bra}\quad &&label_m \span\omit\span \qquad&&\text{; Call main procedure}\\
    &\textbf{(20)}\quad&& &&\inst{pop}\quad &&r_m\quad && &&\text{; Pop '\textit{this}' from stack}\\
    &\textbf{(21)}\quad&& &&\inst{subi}\quad &&r_{sp}\quad &&size_m\qquad &&\text{; Deallocate space of main    object}\\
    &\textbf{(22)}\quad&& &&\inst{exch}\quad &&r_v\quad &&r_{sp}\qquad &&\text{; Pop vtable address into $r_v$}\\
    &\textbf{(23)}\quad&& &&\inst{xori}\quad &&r_v\quad &&label_{vt}\qquad &&\text{; Clear $r_v$}\\
    &\textbf{(24)}\quad&& &&\inst{xor}\quad &&r_m\quad &&r_{sp}\qquad &&\text{; Clear $r_m$}\\
    &\textbf{(25)}\quad&& &&\inst{subi}\quad &&r_{sp}\quad &&offset_{stack} &&\text{; Clear stack pointer}\\
    &\textbf{(26)}\quad&& &&\inst{subi}\quad &&r_{hp}\quad &&size_{fls} &&\text{; Clear heap pointer}\\
    &\textbf{(27)}\quad&& &&\inst{xor}\quad &&r_{hp}\quad &&r_{flsp} &&\text{; Clear heap pointer}\\
    &\textbf{(28)}\quad&& &&\inst{subi}\quad &&r_{flps}\quad &&p &&\text{; Clear free lists pointer}\\
    &\textbf{(29)}\quad&&finish\ \texttt{:}\quad&&\inst{finish}\quad && && &&\text{; Program exit point}
    \end{alignat*}
    \end{minipage}
    }
    \caption{Overall layout of a translated \rooplpp program}
    \label{fig:pisa-program-layout}
\end{figure}

This PISA code block initializes the free lists pointer, the heap pointer, the stack pointer, allocates the main object on the stack, calls the main method, deallocates the main object and finally clears the free lists, heap and stack pointers.

The free lists pointer is initialized by adding the base address, which varies with the size of the translated program, to the register $r_{flps}$. In figure~\ref{fig:pisa-program-layout} the base address is denoted by $p$.

The heap pointer is initialized directly after the free lists pointer by adding the size of the free lists. One free lists is the size of one word and the full size of the free lists is configured in the source code (defaulted to 10, as described earlier).

Once the heap pointer and free lists pointer is initialized, the initial block of free memory is placed in the largest free lists by indexing to said list, by adding the length of the list of free lists, subtracting 1, writing the address of the first block (which is the same address as the heap pointer, which points to the beginning of the heap) to the last free list and then resetting the free lists pointer to point to the 1st list again, afterwards.

The stack pointer is initialized simply by adding the stack offset to the stack register $r_{sp}$. The stack offset is configured in the source code and defaults to $2048$, as described earlier in this chapter. Once the stack pointer has been initialized, the main object is allocated on the stack and the main method called, analogously to the \textsc{Roopl} program structure.

When the program terminates and the main method returns, the main object is popped from the stack and deallocated and the stack pointer is cleared. The heap pointer is then cleared followed by the free lists pointer. The contents of the free lists and whatever is left on the heap is untouched at this point. It is the programmers responsibility to free dynamically allocated objects in their \rooplpp program. Furthermore, depending on the deallocation order, we might not end up with exactly one fully merged block in the end and as such, we do not invert the steps taken to initialize this initial free memory block.
Analogously to \textsc{Roopl}, the values of the main object are left in stack section of memory.


\section{Object Allocation and Deallocation}
\label{sec:object-allocation-deallocation}
As allocation and deallocation intuitively should be each other's inverse, numerous instructions are shared between the two, mainly the core of the reversible buddy algorithm shown in listing~\ref{lst:buddy-memory}. The PISA translated version of the \texttt{malloc1} function from listing~\ref{lst:buddy-memory} is shown in figure~\ref{fig:malloc1-pisa}.

In the translated \texttt{malloc1} function, the \inst{swapbr} functions as entry and exit point, as PISA's paired jumps could not work here, as we need to jump the entry point of the function from multiple locations, so support the recursiveness of the function. Once the entry point has been reached, the return offset obtained from the \inst{swapbr} instruction is negated and stored on the heap. When the function reaches the bottom of the instruction block, a jump to the top is performed where the negated return offset is popped from the stack before the \inst{swapbr} instruction is called again, resulting in a jump to the location which originally branched to the \textit{$malloc1_{entry}$} label. As with the Janus implementation of the algorithm, the PISA version is dependent on a number of arguments, which should be stored in registers. Register $r_{sc}$ hold the block size counter, $r_c$ the free list index counter and $r_{size_c}$ the size of the class. Once the \texttt{malloc1} instructions has completed $r_p$ contains the address of the allocated object. The allocation and deallocation entry points are responsible for settings these, as seen in figure~\ref{fig:pisa-allocation-deallocation}

\begin{figure}[ht]
    \centering
    
    \begin{subfigure}[t]{0.495\linewidth}
    \vskip 0pt
    \centering
    \begin{equation*} 
        \textbf{new}\ c\ x
    \end{equation*}
    
    \resizebox{.8\linewidth}{!}{
    \begin{minipage}{1.025\linewidth}
    \begin{alignat*}{5}
    &\textbf{(1)}\quad&&\inst{addi}\quad &&r_{sc}\quad && 2 \quad &&\text{; Init block size counter}\\
    &\textbf{(2)}\quad&&\inst{xor}\quad &&r_{c}\quad && r_0 &&\text{; Init free list index counter}\\
    &\textbf{(3)}\quad&&\inst{addi}\quad &&r_{size_c}\quad && size_c &&\text{; Init class size}\\
    &\textbf{(4)}\quad&&\inst{bra}\quad &&malloc_{entry_q}\quad \span\omit\span &&\text{; Jump to malloc entry}\\
    &\textbf{(5)}\quad&&\cdots\cdots\quad && && &&\text{; Code for malloc1 (Fig~\ref{fig:malloc1-pisa)})}\\
    &\textbf{(6)}\quad&&\inst{xori}\quad &&r_{t}\quad && label_{vt} &&\text{; Store address of vtable in $r_t$}\\
    &\textbf{(7)}\quad&&\inst{exch}\quad &&r_{t}\quad && r_p &&\text{; Write vtable address in object}\\
    &\textbf{(8)}\quad&&\inst{subi}\quad &&r_{size_c}\quad && size_c &&\text{; Inverse of \textbf{(3)}}\\
    &\textbf{(9)}\quad&&\inst{xor}\quad &&r_{c}\quad && r_0 &&\text{; Inverse of \textbf{(2)}}\\ 
    &\textbf{(10)}\quad&&\inst{subi}\quad &&r_{sc}\quad && 2 &&\text{; Inverse of \textbf{(1)}} 
    \end{alignat*}
    \end{minipage}
    }
    \end{subfigure}
    \begin{subfigure}[t]{0.495\linewidth}
    \vskip 0pt
    \centering
    \begin{equation*}
        \textbf{delete}\ c\ x
    \end{equation*}
    
    \resizebox{.8\linewidth}{!}{
    \begin{minipage}{1.025\linewidth}
    \begin{alignat*}{5}
        &\textbf{(1)}\quad&&\inst{exch}\quad &&r_{t}\quad && r_p &&\text{; Clear vtable in object}\\
        &\textbf{(2)}\quad&&\inst{xori}\quad &&r_{t}\quad && label_{vt} &&\text{; Clear $r_t$}\\
        &\textbf{(3)}\quad&&\inst{addi}\quad &&r_{sc}\quad && 2 \quad &&\text{; Init block size counter}\\
        &\textbf{(4)}\quad&&\inst{xor}\quad &&r_{c}\quad && r_0 &&\text{; Init free list index counter}\\
        &\textbf{(5)}\quad&&\inst{addi}\quad &&r_{size_c}\quad && size_c &&\text{; Init class size}\\
        &\textbf{(6)}\quad&&\inst{bra}\quad &&malloc_{entry_q}\quad \span\omit\span &&\text{; Jump to inverted malloc entry}\\
        &\textbf{(7)}\quad&&\cdots\cdots\quad && && &&\text{; Code for inverted malloc1 (Fig~\ref{fig:malloc1-pisa)})}\\
        &\textbf{(8)}\quad&&\inst{subi}\quad &&r_{size_c}\quad && size_c &&\text{; Inverse of \textbf{(5)}}\\
        &\textbf{(9)}\quad&&\inst{xor}\quad &&r_{c}\quad && r_0 &&\text{; Inverse of \textbf{(4)}}\\
        &\textbf{(10)}\quad&&\inst{subi}\quad &&r_{sc}\quad && 2 &&\text{; Inverse of \textbf{(3)}}
    \end{alignat*}
    \end{minipage}
    }
    \end{subfigure}
    
    \caption{PISA translation of heap allocation and deallocation for objects}
    \label{fig:pisa-allocation-deallocation}
\end{figure}

As mentioned, the \texttt{malloc(1)} is executed recursively, scanning through free blocks in free lists holding blocks of equal or greater size of the $size_c$ we want to allocate. Once such a block has been found, it is recursively split, if its size isn't equal to $size_c$. Before each recursive call (or rather branching in PISA), we must push a number of temporary register values to the stack, to ensure we can re-obtain theres values once the next recursive call returns. These temporary values includes the address of the current free list and the address of its first block, the expression evaluation results needed for the 2 conditional statements along with a temporary register, holding different date depending on where the algorithm branches from. As can be seen in~\ref{fig:malloc1-pisa}, the register pressure is quite high for the heap allocation and deallocation translations. In fact, 11 free registers besides the 4 registers initiated in the code generation for $new$ and $free$ are needed for the translation to succeed. This number of register should obviously be optimized to reduce the register pressure, as taking up 15 registers for allocating or deallocating an object, would only leave 10 free registers available in the current scope, as the free lists, heap and stack pointer further take up 3 registers, the return offset register $r_{ro}$ and register 0 takes up an additional 2. This effectively means that no more than 10 objects can be heap allocation in the same scope, as of writing. The main register hogging part of the translation scheme is the expression evaluation required for the two conditionals (Line 16, 23, 39 and 40 in listing~\ref{lst:buddy-memory}) as the composite expressions such as \texttt{free\_lists[counter] = 0 || p - csize != free\_lists[counter]} currently requires 3 temporary registers for evaluating \texttt{free\_lists[counter] = 0}, \texttt{p - csize != free\_lists[counter]} and finally \texttt{free\_lists[counter] = 0 || p - csize != free\_lists[counter]} separately.  

\begin{figure}[ht]
    \centering
    
    \resizebox{.8\linewidth}{!}{
    \begin{minipage}{\linewidth}
    \begin{alignat*}{7}
    &\textbf{(1)}\quad&&malloc1_{top}\ \texttt{:}\quad  &&\inst{bra}\quad &&malloc1_{bot} \span\omit\span\quad \span\omit\span\quad &&\text{; Receive jump}\\ 
    &\textbf{(2)}\quad&& &&\inst{pop}\quad&&r_{ro}&& && &&\text{; Pop return offset from the stack}\\
    &\textbf{(3)}\quad&& &&\cdots\cdots && && && &&\text{; Inverse of \textbf{(7)}}\\
    &\textbf{(4)}\quad&&malloc1_{entry}\ \texttt{:}\quad&&\inst{swapbr}\quad &&r_{ro} && && &&\text{; Malloc1 entry and exit point}\\
    &\textbf{(5)}\quad&& &&\inst{neg}\quad &&r_{ro} && && &&\text{; Negate return offset}\\        
    &\textbf{(6)}\quad&& &&\inst{push}\quad &&r_{ro} && && &&\text{; Store return offset on stack}\\  
    &\textbf{(7)}\quad&& &&\cdots\cdots && && && &&\text{; Code for $r_{fl}\ \leftarrow\ addr(free\_lists[counter])$}\\
    &\textbf{(8)}\quad&& &&\cdots\cdots && && && &&\text{; Code for $r_{block}\ \leftarrow\ value(free\_lists[counter])$}\\
    &\textbf{(9)}\quad&& &&\cdots\cdots && && && &&\text{; Code for $r_{e1_o}\ \leftarrow\ \llbracket c_{size} < object_{size} \rrbracket$}\\
    &\textbf{(10)}\quad&& &&\inst{xor}\quad &&r_t && r_{e1_o} && &&\text{; Copy value of $c_{size} < object_{size}$ into $r_t$}\\        
    &\textbf{(11)}\quad&& &&\cdots\cdots && && && &&\text{; Inverse of \textbf{(9)}}\\ 
    &\textbf{(12)}\quad&&o_{test}\ \texttt{:}\quad &&\inst{beq} &&r_t && r_0 && o_{test_f} && \text{; Receive jump}\\
    &\textbf{(13)}\quad&& &&\inst{xori} &&r_t && 1 && && \text{; Clear $r_t$}\\
    &\textbf{(14)}\quad&& &&\inst{addi} &&r_{c} && 1 && && \text{; $Counter\texttt{++}$}\\
    &\textbf{(15)}\quad&& &&\inst{rl} &&r_{sc}\ && 1 && && \text{; Call $double(c_{size}$)}\\
    &\textbf{(16)}\quad&& &&\cdots\cdots && && && &&\text{; Code for pushing temp reg values to stack}\\
    &\textbf{(17)}\quad&& &&\inst{bra}\quad &&malloc1_{entry} \span\omit\span\quad \span\omit\span\quad && \text{; Call $malloc1()$)}\\
    &\textbf{(18)}\quad&& &&\cdots\cdots && && && &&\text{; Inverse of \textbf{(16)}}\\
    &\textbf{(19)}\quad&& &&\inst{rr} &&r_{sc}\ && 1 && && \text{; Inverse of \textbf{(15)}}\\
    &\textbf{(20)}\quad&& &&\inst{subi} &&r_{c} && 1 && && \text{; Inverse of \textbf{(14)}}\\
    &\textbf{(21)}\quad&& &&\inst{xori} &&r_t && 1 && && \text{; Set $r_t = 1$}\\
    &\textbf{(22)}\quad&&o_{assert_t}\ \texttt{:}\quad &&\inst{bra} &&o_{assert} \span\omit\span\quad \span\omit\span\quad && \text{; Jump}\\
    &\textbf{(23)}\quad&&o_{test_f}\ \texttt{:}\quad &&\inst{bra} &&o_{test} \span\omit\span\quad \span\omit\span\quad && \text{; Receive jump}\\
    &\textbf{(24)}\quad&& &&\cdots\cdots && && && &&\text{; Code for $r_{e1_i}\ \leftarrow\ \llbracket addr(free\_lists[counter]) \neq 0 \rrbracket$}\\
    &\textbf{(25)}\quad&& &&\inst{xor}\quad &&r_{t2} && r_{e1_i} && &&\text{; Copy value of $r_{e1_i}$ into $r_{t2}$}\\        
    &\textbf{(26)}\quad&& &&\cdots\cdots && && && &&\text{; Inverse of \textbf{(24)}}\\
    &\textbf{(27)}\quad&&i_{test}\ \texttt{:}\quad &&\inst{beq} &&r_{t2} && r_0 && i_{test_f} && \text{; Receive jump}\\
    &\textbf{(28)}\quad&& &&\inst{xori} &&r_{t2} && 1 && && \text{; Clear $r_{t2}$}\\
    &\textbf{(29)}\quad&& &&\inst{add} &&r_{p} && r_{block} && && \text{; Copy address of the current block to p}\\
    &\textbf{(30)}\quad&& &&\inst{sub} &&r_{block}\ && r_{p} && && \text{; Clear $r_{block}$}\\
    &\textbf{(31)}\quad&& &&\inst{exch} &&r_{tmp} && r_{p} && && \text{; Load address of next block}\\
    &\textbf{(32)}\quad&& &&\inst{exch} &&r_{tmp} && r_{fl} && && \text{; Set address of next block as new head of free list}\\
    &\textbf{(33)}\quad&& &&\inst{xor} &&r_{tmp} && r_{p} && && \text{; Clear address of next block}\\
    &\textbf{(34)}\quad&& &&\inst{xori} &&r_{t2} && 1 && && \text{; Set $r_{t2} = 1$}\\
    &\textbf{(35)}\quad&&i_{assert_t}\ \texttt{:}\quad &&\inst{bra} &&i_{assert} \span\omit\span\quad \span\omit\span\quad && \text{; Jump}\\
    &\textbf{(36)}\quad&&i_{test_f}\ \texttt{:}\quad &&\inst{bra} &&i_{test} \span\omit\span\quad \span\omit\span\quad && \text{; Receive jump}\\
    &\textbf{(37)}\quad&& &&\inst{addi} &&r_{c} && 1 && && \text{; $Counter\texttt{++}$}\\
    &\textbf{(38)}\quad&& &&\inst{rl} &&r_{sc}\ && 1 && && \text{; Call $double(c_{size}$)}\\
    &\textbf{(39)}\quad&& &&\cdots\cdots && && && &&\text{; Code for pushing temp reg values to stack}\\
    &\textbf{(40)}\quad&& &&\inst{bra}\quad &&malloc1_{entry} \span\omit\span\quad \span\omit\span\quad && \text{; Call $malloc1()$)}\\
    &\textbf{(41)}\quad&& &&\cdots\cdots && && && &&\text{; Inverse of \textbf{(39)}}\\
    &\textbf{(42)}\quad&& &&\inst{rr} &&r_{sc}\ && 1 && && \text{; Inverse of \textbf{(38)}}\\
    &\textbf{(43)}\quad&& &&\inst{subi} &&r_{c} && 1 && && \text{; Inverse of \textbf{(37)}}\\
    &\textbf{(44)}\quad&& &&\inst{xor} &&r_{tmp} && r_p && && \text{; Copy current address of p}\\
    &\textbf{(45)}\quad&& &&\inst{exch} &&r_{tmp} && r_{fl} && && \text{; Store current address of p in current free list}\\
    &\textbf{(46)}\quad&& &&\inst{add} &&r_{p} && r_{cs} && && \text{; Split block by setting p to the second half of the current block}\\
    &\textbf{(47)}\quad&&i_{assert}\ \texttt{:}\quad &&\inst{bne} &&r_{t2} && r_0 && i_{assert_t} && \text{; Receive jump}\\
    &\textbf{(48)}\quad&& &&\inst{exch} &&r_{tmp} && r_{fl} && && \text{; Load address of head of current free list}\\
    &\textbf{(49)}\quad&& &&\inst{sub} &&r_{p} && r_{cs} && && \text{; Set p to previous block address}\\
    &\textbf{(50)}\quad&& &&\cdots\cdots && && && &&\text{; Code for $r_{e2_{i1}}\ \leftarrow\ \llbracket p - c_{size} \neq addr(free\_lists[counter])\rrbracket$}\\
    &\textbf{(51)}\quad&& &&\cdots\cdots && && && &&\text{; Code for $r_{e2_{i2}}\ \leftarrow\ \llbracket addr(free\_lists[counter]) = 0 \rrbracket$}\\
    &\textbf{(52)}\quad&& &&\cdots\cdots && && && &&\text{; Code for $r_{e2_{i3}}\ \leftarrow\ \llbracket (p - c_{size} \neq addr(free\_lists[counter])) \vee (addr(free\_lists[counter]) = 0) \rrbracket$}\\
    &\textbf{(53)}\quad&& &&\inst{xor} &&r_{r2} && r_{e2_{i3}} && && \text{; Copy value of $r_{e2_{i3}}$ into $r_{t2}$}\\
    &\textbf{(54)}\quad&& &&\cdots\cdots && && && &&\text{; Inverse of \textbf{(52)}}\\
    &\textbf{(55)}\quad&& &&\cdots\cdots && && && &&\text{; Inverse of \textbf{(51)}}\\
    &\textbf{(56)}\quad&& &&\cdots\cdots && && && &&\text{; Inverse of \textbf{(50)}}\\
    &\textbf{(57)}\quad&& &&\inst{add} &&r_{p} && r_{cs} && && \text{; Inverse of \textbf{(49)}}\\
    &\textbf{(58)}\quad&& &&\inst{exch} &&r_{tmp} && r_{fl} && && \text{; Inverse of \textbf{(48)}}\\
    &\textbf{(59)}\quad&&o_{assert}\ \texttt{:}\quad &&\inst{bne} &&r_{t} && r_0 && o_{assert_t} && \text{; Receive jump}\\
    &\textbf{(60)}\quad&& &&\cdots\cdots && && && &&\text{; Code for $r_{e2_o}\ \leftarrow\ \llbracket c_{size} < object_{size} \rrbracket$}\\
    &\textbf{(61)}\quad&& &&\inst{xor}\quad &&r_t && r_{e2_o} && &&\text{; Copy value of $c_{size} < object_{size}$ into $r_t$}\\        
    &\textbf{(62)}\quad&& &&\cdots\cdots && && && &&\text{; Inverse of \textbf{(60)}}\\ 
    &\textbf{(63)}\quad&&malloc1_{bot}\ \texttt{:}\quad  &&\inst{bra}\quad &&malloc1_{top} \span\omit\span\quad \span\omit\span\quad &&\text{; Jump}\\
    \end{alignat*}
    \end{minipage}
    }
    
    \caption{The core of the reversible buddy memory algorithm translated into PISA. For deallocation the inverse of this block is generated during compile-time.}
    \label{fig:malloc1-pisa} 
\end{figure}

\newpage

\section{Arrays}
\label{sec:arrays}
% TODO: Write section

\subsection{Construction and destruction}
\label{subsec:construction-destruction}
%TODO: Write subsection

\subsection{Array Element Access}
\label{subsec:array-element-access}
% TODO: Write subsection

\section{Referencing}
\label{sec:referencing-compilation}
% TODO: Write section

\section{Error Handling}
\label{sec:error-handling}

While a program written in \rooplpp might be syntactically valid and well-typed, it is not a guarantee that it compiles successfully. A number of conditions exists, which cannot be determined at compile time, which results in erroneous compiled code. \citeauthor{th:roopl} describes the following conditions:

\begin{itemize}
    \item If the entry expression of a conditional is \textbf{true}, then the exit assertion should also be \textbf{true} after executing the then-branch.
    \item If the entry expression of a conditional is \textbf{false}, then the exit assertion should also be \textbf{false} after executing the else-branch.
    \item The entry expression of a loop should initially be \textbf{true}.
    \item If the exit assertion of a loop is \textbf{false}, then the entry expression should also be \textbf{false} after executing the loop-statement.
    \item All instance variables should be zero-cleared within an object block, before the object is deallocated.
    \item The value of a local variable should always match the value of the delocal-expression after the block statement has executed.
\end{itemize}

The extensions made to \textsc{Roopl} in \rooplpp brings forth a number of additional conditions:

\begin{itemize}
    \item All fields of an object instance should be zero-cleared before the object is deallocated using the \textbf{delete} statement.
    \item All cells of an an instance should be zero-cleared before the array is deallocated using the \textbf{delete} statement.
    \item Local object blocks should have their fields zero-cleared after the execution of the block statement.
    \item Local array blocks should have their cells zero-cleared after the execution of the block statement.
    \item If a local object variable's value is exchanged during its block statement and the new value is an object reference, this object must have its fields zero-cleared after the execution of the block statement.
    \item If a local array variable's value is exchanged during its block statement and the new value is an array reference, this array must have its cell zero-cleared after the execution of the block statement.
    \item The variable in the \textbf{new} statement must be zero-cleared beforehand.
    \item The variable in the \textbf{copy} statement must be zero-cleared beforehand.
    \item The variable in the \textbf{copy} statement must be zero-cleared beforehand.    \item The variable in the \textbf{new} statement must be zero-cleared beforehand.
\end{itemize}

It is the programmer's responsibility to meet these conditions are met. As these conditions, in general, cannot be determined at compile time, undefined program behaviour will occur as the termination will continue silently, resulting in erroneous program state.

% TODO: Finish section

\section{Implementation}
\label{sec:implementation}
% TODO: Write section
