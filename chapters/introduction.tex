\chapter{Introduction}
\label{chp:introduction}
In recent years, technologies such as cloud-based services, cryptocurrency mining and other services requiring large computational power and availability have been on the rise. Most of these services are hosted on massive server parks, consuming immense amounts of electricity in order to power the machines and the cooling architectures as heat dissipates from the hardware. A recent study showed that the Bitcoin network including its mining processes' currently stands at 0.13\% of the total global electricity consumption, rivaling the usage of a small country like Denmark's~\cite{digiconomist:bitcoin}. With the recent years focus on climate and particularly energy consumption, companies have started to attempt to reduce their power usage in these massive server farms. As an example, Facebook built new server park in the arctic circle in 2013, in an attempt to take advantage of the natural surroundings in the cooling architecture to reduce its power consumption~\cite{bloomberg:facebook}. 

Reversible computing presents a possible solution the problematic power consumption issues revolving around computations. Traditional, irreversible computers dissipates heat during their computation. Landauer's principle states that deletion of information in a system always results by an increase in energy consumption. In reversible computing, all information is preserved throughout the execution, and as such, the energy consumption theoretically should be smaller~\cite{rl:irreversibility}.

Currently, reversible computing is not commercially appealing, as it is an area which still is being actively researched. However, several steps has been taken in the direction of a fully reversible system, which some day might be applicable in a large setting. Reversible machine architectures have been presented such as the Pendulum architecture and its instruction set Pendulum ISA (\textsc{Pisa})~\cite{cv:pendulum, ha:architecture} and the \textsc{BobISA} architecture and instruction set~\cite{mt:bob} and high level languages \textsc{Janus}~\cite{cl:janus, ty:janus, ty:ejanus} and \textsc{R}~\cite{mf:r} exists. 

While cryptocurrency mining and many other computations are not reversible, the area remains interesting in terms of its applications and gains.


\section{Reversible Computing}
\label{sec:reversible-computing}
Reversible computing is a two-directional computational model in which all processes are time-invertible. This means, that at any time during execution, the computation can return to a former state. In order to maintain \textit{reversibility}, the reversible computational model cannot compute \textit{many-to-one} functions, as the models requires an exact inverse $f^{-1}$ of a function $f$ in order to support backwards determinism. Therefore, reversible programs must only consist of \textit{one-to-one} functions, also known as \textit{injective} functions, which result in a garbage-free computation, as garbage-generating functions simply can be unwinded to clean up.

Each step of a reversible program is locally invertible, meaning each of its component has exactly one inverse component. A reversible program can be inverted simply by computing the inverse of each of its components, without any knowledge about the overall program's functionality or requirements. This property immediately yields interesting consequences in terms of software development, as an encryption or compression algorithm implemented in a reversible language immediately yields the decryption or decompression algorithm by running the algorithm in backwards direction.

The reversibility is however not free and comes and the cost of strictness when writing programs. Almost every popular, irreversible programming language features a conditional component in form of \textbf{if}-\textbf{else}-statements. In these languages, we only define the \textit{entry}-condition in the conditional, that is, the condition that determines which branch of the component we continue execution in. In reversible languages, we must also specify an \textit{exit}-condition, such that we can determine which branch we should follow, when executing the program in reverse. In theory, this sounds trivial, but in practice it turns to add a new layer of complexity when writing programs.


\section{Object-Oriented Programming}
\label{sec:object-oriented-programming}
Object-oriented programming (OOP) has for many years been the most widely used programming paradigm as reflected in the popular usage of object-oriented programming languages, such as the \textsc{C}-family languages, \textsc{Java}, \textsc{PHP} and in recent years \textsc{Javascript} and \textsc{Python}. The OOP core concepts such as \textit{inheritance}, \textit{encapsulation} and \textit{polymorphism} allows complex systems to be modeled by breaking the system into smaller parts in form of abstract objects~\cite{jm:concepts}.


\section{Reversible Object-Oriented Programming}
\label{sec:reversible-object-oriented-programming}
The high-level reversible language \textsc{Roopl} (Reversible Object-Oriented Programming Language) was introduced in late 2016~\cite{th:roopl, th:roopl2}. The language extends the design of previously existing reversible imperative languages with object-oriented programming language features such as user-defined data types, class inheritance and subtype-polymorphism. As a first, \textsc{Roopl} successfully integrates the object-oriented programming (OOP) paradigms into the reversible computation setting using a static memory manager to maintain garbage-free computation, but at cost of programmer usability as objects only lives within \textbf{construct} / \textbf{deconstruct} blocks, which needs to be predefined, as the program call stack is required to be reset before program termination.

Conceptualizations and ideas for the \textsc{Joule} language was also published in 2016~\cite{us:joule}. The language, a homonym of \textsc{Janus Object-Oriented Language}, \textsc{Jool}, presented an alternative OOP extension to \textsc{Janus}, differing from \textsc{Roopl}. The language featured heap allocated objects with constructors and multiple object references, as such also addressing the problems with \textsc{Roopl}. The language is still a work in progress, aiming to provide a useful, reversible object oriented-programming language.
 

\section{Motivation}
\label{sec:motivation}
\textsc{Roopl}'s block defined objects and lack of references are problematic when writing complex, reversible programs using OOP methodologies as they pose severe limitations on the expressiveness. It has therefore been proposed to extend and partially redesign the language with dynamic memory management in mind, such that these shortcomings can be addressed, and ultimately increase the usability of reversible OOP. Work within the field of reversible computing related to heap manipulation~\cite{ha:heap}, reference counting~\cite{tm:refcounting} and garbage collection~\cite{tm:garbage} suggests that a \textsc{Roopl} extension is feasible.


\section{Thesis Statement}
\label{sec:thesis-statement}
An extension of the reversible object-oriented programming language with dynamic memory management is feasible and effective. The resulting expressiveness allows non-trivial reversible programming previously unseen, such as reversible data structures, including linked lists, doubly linked lists and trees.

\section{Outline}
\label{sec:outline}
This Master's thesis consists of four chapters, besides the introductory chapter. The following summary describes the following chapters.
\begin{itemize}
    \item \textbf{Chapter 2} formally defines the \textsc{Roopl} extension exemplified by the new language \rooplpp, a superset of \textsc{Roopl}.
    \item \textbf{Chapter 3} serves as a brief description of dynamic memory management along with a discussion of various reversible, dynamic memory management layouts.
    \item \textbf{Chapter 4} presents the translation techniques utilized in compiling a \rooplpp program to \textsc{Pisa} instructions.
    \item \textbf{Chapter 5} presents the conclusions of the thesis and future work proposals.
\end{itemize}

Besides the five chapters, a number of appendices is supplied, containing \textsc{Pisa} translations of the reversible heap allocation algorithm, the source code of the \rooplpp to \textsc{Pisa} compiler, the \rooplpp source code for the example programs and their translated \textsc{Pisa} versions.