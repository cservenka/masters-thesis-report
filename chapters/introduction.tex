\chapter{Introduction}
\texttt{TODO}

\section{Reversible Computing}
\texttt{TODO}

\section{Reversible Object-Oriented Programming}
The high-level reversible language \textsc{Roopl} (Reversible Object-Oriented Programming Language) was introduced in late 2016 and is, to our knowledge, the first of its kind~\cite{th:roopl}. The language extends the design of previously existing reversible imperative languages with object-oriented programming language features such as user-defined data types, class inheritance and subtype-polymorphism. As a first, \textsc{Roopl} successfully integrates the object-oriented programming (OOP) paradigms into the reversible computation setting using a static memory manager to maintain garbage-free computation, but at cost of "programmer usability" as objects only lives within \texttt{construct} / \texttt{deconstruct} blocks, which needs to be predefined, as the program call stacks is required to be reset before program termination.

\section{Motivation}
\textsc{Roopl}'s block defined objects and lack of references are problematic when write complex, reversible programs using OOP methodologies. It has therefore been proposed to extend and partially redesign the language with dynamic memory management in mind, such that these shortcomings can be addressed, ultimately increasing the usability of reversible OOP. Work within the field of reversible computing related to heap manipulation~\cite{ha:heap}, reference counting~\cite{tm:refcounting} and garbage collection~\cite{tm:garbage} suggests that a \textsc{Roopl} extension is feasible.



\section{Thesis Statement}
\texttt{TBD}

\section{Outline}
\texttt{TBC}